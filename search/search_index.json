{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unity Wiki","text":"<p>This is a place where I document my learnings as I go through various courses on Unity</p>"},{"location":"2d-games/animator/","title":"Animator","text":""},{"location":"2d-games/animator/#animator","title":"Animator","text":"<ul> <li>Create an <code>Animator Controller</code> call <code>Player_AC</code></li> <li>Add <code>Animator Controller</code> to the game object where the <code>Sprite Renderer</code> is located</li> <li>Create an <code>Animation</code> and drag the desired sprites</li> <li>Select hamburger icon and select <code>Show Sample Rate</code></li> </ul>"},{"location":"2d-games/animator/#to-create-more-animations","title":"To Create More Animations","text":"<ul> <li>Select <code>Animator</code></li> <li>Select <code>Create New Clip</code></li> </ul>"},{"location":"2d-games/animator/#transition-between-animations","title":"Transition Between Animations","text":"<ul> <li>Select <code>Parameters</code> and click <code>+</code> and add desired type.</li> <li>Select <code>Make Transition</code> between animation states</li> <li>Go to <code>Conditions</code> and add <code>Parameters</code> to move between states</li> <li>Uncheck <code>Exit Time</code></li> <li>Set <code>Transition Duration</code> to 0</li> </ul>"},{"location":"2d-games/animator/#flipping-character","title":"Flipping Character","text":"<ul> <li>To flip character, rotate on the <code>Y</code> axis 180 degrees</li> </ul> <pre><code>private void Flip()\n{\nfacingDir *= -1;\nfacingRight = !facingRight;\ntransform.Rotate(0, 180, 0);\n}\n\nprivate void FlipController()\n{\nif (rb.velocity.x &gt; 0 &amp;&amp; !facingRight) Flip();\nelse if (rb.velocity.x &lt; 0 &amp;&amp; facingRight) Flip();\n}\n</code></pre>"},{"location":"2d-games/sprite-sheet/","title":"Sprite Sheet","text":""},{"location":"2d-games/sprite-sheet/#sprite-sheet","title":"Sprite Sheet","text":""},{"location":"2d-games/sprite-sheet/#slice-the-sheet","title":"Slice the Sheet","text":"<ul> <li>Set <code>Sprite Mode</code> to <code>Multiple</code></li> <li>Go to <code>Sprite Editor</code> and select <code>Slice</code></li> <li>Set <code>Type</code> of <code>Grid By Cell Size</code></li> <li>X: 69, y: 44</li> <li>Apply</li> </ul>"},{"location":"2d-games/sprite-sheet/#size","title":"Size","text":"<ul> <li>Change <code>Pixel Per Unit</code> to 16</li> </ul>"},{"location":"2d-games/sprite-sheet/#image-quality","title":"Image Quality","text":"<ul> <li>Set <code>Compression</code> to <code>None</code></li> <li>Set <code>Filter Mode</code> to <code>Point (no filter)</code></li> <li>Apply</li> </ul>"},{"location":"2d-games/sprite-sheet/#center-sprite","title":"Center Sprite","text":"<ul> <li>Remove the <code>Sprite Renderer</code> component from the <code>Player</code></li> <li>Create a empty child object called <code>Animator</code></li> <li>Set the <code>x</code> position to 0.4</li> </ul>"},{"location":"2d-games/sprite-sheet/#final-settings","title":"Final Settings","text":"<ul> <li>Add <code>Capsule Collider 2D</code> to the <code>Player</code></li> <li>Set <code>Freeze Rotation</code> on <code>Z</code></li> <li>Set <code>Collision Detection</code> to <code>Continuous</code></li> <li>Set <code>Interpolate</code> to <code>Interpolate</code></li> </ul> <p>The Interpolate setting on a Rigidbody provides two options to smooth the appearance of a Rigidbody\u2019s motion if it appears jittery at run time. These options are Interpolate and Extrapolate.</p> <p>Both interpolation and extrapolation calculate the pose of the Rigidbody (that is, the position and rotation) between physics updates. Which one you should choose depends on which option produces the best visual outcome for your use case.</p>"},{"location":"fps-multiplayer/get-connected/","title":"Get Connected","text":""},{"location":"fps-multiplayer/get-connected/#setting-up-photon","title":"Setting Up Photon","text":"<ul> <li>Install PUN2 from the Unity Asset Store: https://assetstore.unity.com/packages/tools/network/pun-2-free-119922</li> <li>Before importing into our project, de-select the demo checkboxes</li> <li>Create an account here: https://www.photonengine.com/</li> <li>Create a new app and note the <code>app id</code>. This will be required as part of the PUN setup in Unity.</li> <li>Under <code>Assets/Photon/PhotonUnityNetworking/Resources/PhotonServerSettings</code>, change <code>Fixed Region</code> to <code>us</code></li> </ul>"},{"location":"fps-multiplayer/get-connected/#laying-out-the-connection-menu","title":"Laying Out The Connection Menu","text":"<ul> <li>Create a new scene for the main menu and save it in the <code>scenes</code> folder as <code>main menu</code>.</li> <li>Set up the basic buttons for the menu by creating a UI canvas, renaming it to <code>menu canvas</code>, and adjusting the canvas settings to scale with screen size.</li> <li>Add a title text to the top of the canvas to display the name of the game.</li> <li>Create buttons for the menu system by adding UI button elements and customizing their appearance, size, and position.</li> <li>Convert the button into a prefab by dragging it into the prefabs folder. This allows for easy reuse of the button design in different scenes.</li> <li>Create additional buttons for different menu options such as <code>Find Room</code>, <code>Create Room</code>, and <code>Quit Game</code>. Customize the text and appearance of each button as needed.</li> <li>Organize the buttons using a Vertical Layout Group component in a parent object called <code>menu buttons</code>. Adjust the positioning and spacing of the buttons within the layout.</li> <li>Add a loading panel by creating a UI panel element. Customize the panel's appearance, size, and position to display loading information.</li> <li>Add loading text to the loading panel using a UI TextMeshPro element. Customize the text appearance and positioning.</li> <li>Import a 3D model of a city as a background for the menu scene. Adjust the position and rotation of the camera to create a visually appealing view.</li> <li>Save the scene and proceed to the next steps, which will involve connecting the menu buttons to the actual game functionality.</li> </ul>"},{"location":"fps-multiplayer/get-connected/#connecting-to-the-server","title":"Connecting To The Server","text":"<ul> <li>Create a new script called <code>Launcher</code> and open it in the script editor.</li> <li>Make the launcher a static instance (<code>public static Launcher instance</code>).</li> <li>In the <code>Awake()</code> function, assign the instance to <code>this</code>.</li> <li>Import Photon Unity Networking by adding <code>using Photon.Pun</code> at the top of the script.</li> <li>Replace <code>MonoBehaviour</code> with <code>MonoBehaviourPunCallbacks</code>.</li> <li>Add references for the loading screen, menu buttons, and loading text (Te\u00e5xtMeshPro element).</li> <li>Create a void function called <code>CloseMenus()</code> to close any open menus.</li> <li>In the <code>Start()</code> function, close all menus, then set the loading screen active and update the loading text to say <code>Connecting to Network.</code></li> <li>Connect to the Photon network using <code>PhotonNetwork.ConnectUsingSettings()</code>.</li> <li>Create a public override void function called <code>OnConnectedToMaster()</code>.</li> <li>In OnConnectedToMaster(), join the lobby using <code>PhotonNetwork.JoinLobby()</code> and update the loading text to say <code>Joining Lobby.</code></li> <li>Remove the menu buttons activation code from <code>OnConnectedToMaster()</code> as it will be moved to another function.</li> <li>Create another override void function called <code>OnJoinedLobby()</code>.</li> <li>In <code>OnJoinedLobby()</code>, activate the menu buttons.</li> </ul> <p>After completing these steps, you should have a basic networking system in place. When the game starts, it will display a loading screen with the text <code>Connecting to Network,</code> then briefly change to <code>Joining Lobby</code> before displaying the menu buttons. From this point, you can continue to implement creating and joining rooms for your game.</p> <p><code>Launcher.cs</code></p> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Photon.Pun;\nusing UnityEngine.UI;\nusing Unity.VisualScripting;\nusing TMPro;\n\npublic class Launcher : MonoBehaviourPunCallbacks\n{\npublic static Launcher instance;\npublic GameObject loadingScreen;\npublic TextMeshProUGUI loadingText;\npublic GameObject menuButtons;\n\nprivate void Awake()\n{\nif (instance != null)\n{\nDestroy(gameObject);\nreturn;\n}\ninstance = this;\nDontDestroyOnLoad(gameObject);\n}\n\n// Start is called before the first frame update\nvoid Start()\n{\nCloseMenus();\nloadingScreen.SetActive(true);\nloadingText.text = \"Connecting To Network...\";\n\nPhotonNetwork.ConnectUsingSettings();\n}\n\nvoid CloseMenus()\n{\nloadingScreen.SetActive(false);\nmenuButtons.SetActive(false);\n}\n\npublic override void OnConnectedToMaster()\n{\nPhotonNetwork.JoinLobby();\nloadingText.text = \"Joining Lobby...\";\n}\n\npublic override void OnJoinedLobby()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#setting-up-room-creation","title":"Setting Up Room Creation","text":"<ul> <li>Duplicate the existing <code>Loading Panel</code> and rename it to <code>Create Room Panel.</code></li> <li>Open the new panel and remove the <code>loading text.</code></li> <li>Add a <code>UI &gt; Input Field - TextMeshPro</code> and rename it to <code>Room Name Input Field</code> to let users input the room's name.</li> <li>Set the input field's width to 800 and height to 100.</li> <li>Modify the placeholder text to guide the user (e.g., <code>enter room name here</code>) and adjust the font style and size.</li> <li>Center the text component and adjust its font style and size.</li> <li>Add a button to the panel, name it <code>Create Room</code> button, and position it appropriately.</li> <li>Deactivate the <code>Create Room Panel.</code></li> <li>In the <code>Launcher</code> script, create references to the <code>Room Input Field</code> and the <code>Create Room Panel</code> by declaring two public variables.</li> <li>Add the <code>Create Room Panel</code> to the list of <code>closable menus.</code></li> <li>Create a new function called <code>OpenRoomCreate()</code> to open the room creation screen and set the <code>Create Room panel</code> to active.</li> <li>In Unity, connect the <code>Create Room Panel</code> and the input field to the public variables in the script.</li> <li>Set up the <code>Create Room</code> button to call the <code>OpenRoomCreate()</code> function when clicked.</li> <li>Test the <code>room creation panel</code> in Unity by playing the game and clicking the <code>Create Room</code> button.</li> </ul> <pre><code>public GameObject createRoomScreen;\npublic TMP_InputField roomInputField;\n\nvoid CloseMenus()\n{\n//..\ncreateRoomScreen.SetActive(false);\n}\n\npublic void OpenRoomCreate()\n{\nCloseMenus();\ncreateRoomScreen.SetActive(true);\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#creating-a-room","title":"Creating A Room","text":"<ul> <li>In the <code>Launcher</code> script, create a new function called \"CreateRoom()\"</li> <li>Save the script and assign the function to the \"Create Room\" button in Unity.</li> <li>Go back to the script and add an if statement to ensure that the player has entered a room name.</li> <li>Use the <code>string.IsNullOrEmpty()</code> function to check if the input field is empty.</li> <li>If the input field is not empty, call <code>PhotonNetwork.CreateRoom()</code> to create a new room with the player's input as the room name.</li> <li>To set a maximum number of players for the room, create a reference to the <code>RoomOptions</code> class. This requires adding <code>using Photon.Realtime;</code> at the top of the script.</li> <li>Create a <code>RoomOptions</code> variable called <code>options</code> and set it to a <code>new RoomOptions</code> instance.</li> <li>Set the maximum number of players for the room by assigning a value to options.MaxPlayers (e.g., <code>options.MaxPlayers = 8;</code>).</li> <li>Pass the <code>options</code> variable as a parameter when creating the room with <code>PhotonNetwork.CreateRoom()</code>.</li> <li>Close any open menus, set the loading text to <code>Creating Room</code>, and activate the loading screen.</li> <li>Save the script and test the room creation functionality in Unity.</li> </ul> <pre><code>using Photon.Realtime;\n\npublic void CreateRoom()\n{\nif (!string.IsNullOrEmpty(roomInputField.text))\n{\nRoomOptions options = new RoomOptions();\noptions.MaxPlayers = 8;\nPhotonNetwork.CreateRoom(roomInputField.text, options);\nCloseMenus();\nloadingText.text = \"Creating Room...\";\nloadingScreen.SetActive(true);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#joining-the-created-room","title":"Joining The Created Room","text":"<ul> <li>Close the <code>Create Room</code> panel in the Unity editor.</li> <li>Duplicate the <code>Loading Panel</code>, and rename the new panel to <code>Room Panel.</code></li> <li>Make the <code>Room Panel</code> visible.</li> <li>Modify the loading text to <code>Room Name Text,</code> move it to the top of the screen, and adjust its anchors accordingly.</li> <li>Add a UI button to the room panel, anchor it to the bottom, name it <code>Leave Button,</code> and set its text to <code>Leave Room.</code></li> <li>In the <code>Launcher</code> script, create references to the room panel and room text.</li> <li>Add <code>public GameObject roomScreen</code> and <code>public TextMeshProUGUI</code>roomNameText` variables.</li> <li>In the same script, scroll down to the <code>Create Room</code> section, and create a new override method: <code>override void OnJoinedRoom()</code>. Remove the base method call, so only your custom functionality remains.</li> <li>Inside the <code>OnJoinedRoom()</code> method, first, close the menus by ensuring that <code>roomScreen.SetActive(false)</code> is called.</li> <li>Set <code>roomScreen.SetActive(true)</code> to make the room screen visible when the player joins the room.</li> <li>Update the room name text by setting <code>roomNameText.text = PhotonNetwork.CurrentRoom.Name;</code> This displays the name of the currently connected room.</li> <li>Save the script and return to the Unity editor to let it compile.</li> <li>Assign the <code>roomScreen</code> and <code>roomNameText</code> references in the <code>Launcher</code> script component within the Unity editor.</li> <li>Test the functionality by playing the Unity project. Enter a menu, create a room, and observe that the room is joined, displaying the room information on the room panel.</li> </ul> <pre><code>public GameObject roomScreen;\npublic TextMeshProUGUI roomNameText;\n\npublic override void OnJoinedRoom()\n{\nCloseMenus();\nroomScreen.SetActive(true);\nroomNameText.text = PhotonNetwork.CurrentRoom.Name;\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#handling-creation-errors","title":"Handling Creation Errors","text":"<ul> <li>Create an <code>Error Panel</code> by duplicating the <code>Loading Panel</code> and renaming it to <code>error panel.</code></li> <li>Change the error panel's text to <code>Error Text</code> and set its color to <code>red</code> to indicate a warning.</li> <li>Add a <code>Close</code> button at the bottom of the error panel to allow users to close the error screen.</li> <li>In the <code>Launcher</code> script, add a <code>public GameObject errorScreen</code> and a <code>public TextMeshProUGUI errorText</code> for references to the error panel and its text.</li> <li>In the <code>CloseMenus()</code> function, add <code>errorScreen.SetActive(false);</code> to hide the error screen when other menus are closed.</li> <li>In the <code>Launcher</code> script, create an override method for handling room creation failure: <code>public override void OnCreateRoomFailed(short returnCode, string message)</code></li> <li>Inside the <code>OnCreateRoomFailed()</code> method, set the error text to display the failure message: <code>errorText.text = \"Failed to create room: \" + message;</code></li> <li>Close other menus and activate the error screen with <code>CloseMenus();</code> and <code>errorScreen.SetActive(true);</code></li> <li>Create a new function to close the error screen and return to the main menu: <code>public void CloseErrorScreen().</code></li> <li>In the <code>CloseErrorScreen()</code> function, call <code>CloseMenus();</code> and set the main menu buttons to be active: <code>menuButtons.SetActive(true);</code></li> <li>In the Unity editor, assign the <code>CloseErrorScreen()</code> function to the <code>Close</code> button on the error panel.</li> <li>Assign the error panel and error text references in the <code>Launcher</code> script component within the Unity editor.</li> <li>Test the error handling functionality by running two instances of the game, creating a room with the same name in both instances, and ensuring the error message is displayed when room creation fails in the second instance.</li> </ul> <pre><code>public GameObject errorScreen;\npublic TextMeshProUGUI errorText;\n\npublic override void OnCreateRoomFailed(short returnCode, string message)\n{\nerrorText.text = \"Failed to create room: \" + message;\nCloseMenus();\nerrorScreen.SetActive(true);\n}\n\npublic void CloseErrorScreen()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#leaving-a-room","title":"Leaving A Room","text":"<ul> <li>In the <code>Launcher</code> script, create a new public function called <code>LeaveRoom()</code> which will be called when the leave button is clicked.</li> <li>In the <code>LeaveRoom()</code> function, tell Photon to leave the room with the following command: <code>PhotonNetwork.LeaveRoom();</code></li> <li>Close the current menus by calling the <code>CloseMenus();</code> function.</li> <li>Update the loading text to inform the user that they are leaving the room: <code>loadingText.text = \"Leaving Room...\";</code></li> <li>Set the loading screen to active by using <code>loadingScreen.SetActive(true);</code></li> <li>Create a new public override function called <code>OnLeftRoom()</code> which will be called when Photon detects that the user has left the room.</li> <li>In the <code>OnLeftRoom()</code> function, close the current menus (which should include the loading menu) by calling <code>CloseMenus();</code></li> <li>Set the main menu buttons to active by using <code>menuButtons.SetActive(true);</code></li> <li>Save the script and return to the Unity editor.</li> <li>On the room panel, assign the <code>LeaveRoom()</code> function to the leave button's onClick event.</li> <li>Test the functionality by running the game, joining the lobby, creating a room, and then leaving the room. The loading screen should briefly appear, and the user should be returned to the main menu.</li> </ul> <pre><code>public void LeaveRoom()\n{\nPhotonNetwork.LeaveRoom();\nCloseMenus();\nloadingText.text = \"Leaving Room...\";\nloadingScreen.SetActive(true);\n}\n\npublic override void OnLeftRoom()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n</code></pre>"},{"location":"fps-multiplayer/get-connected/#code","title":"Code","text":""},{"location":"fps-multiplayer/get-connected/#launchercs","title":"Launcher.cs","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Photon.Pun;\nusing UnityEngine.UI;\nusing Unity.VisualScripting;\nusing TMPro;\nusing Photon.Realtime;\n\npublic class Launcher : MonoBehaviourPunCallbacks\n{\npublic static Launcher instance;\npublic GameObject loadingScreen;\npublic TextMeshProUGUI loadingText;\n\npublic GameObject menuButtons;\n\npublic GameObject createRoomScreen;\npublic TMP_InputField roomInputField;\n\npublic GameObject roomScreen;\npublic TextMeshProUGUI roomNameText;\n\npublic GameObject errorScreen;\npublic TextMeshProUGUI errorText;\n\nprivate void Awake()\n{\ninstance = this;\n}\n\n// Start is called before the first frame update\nvoid Start()\n{\nCloseMenus();\nloadingScreen.SetActive(true);\nloadingText.text = \"Connecting To Network...\";\n\nPhotonNetwork.ConnectUsingSettings();\n}\n\nvoid CloseMenus()\n{\nloadingScreen.SetActive(false);\nmenuButtons.SetActive(false);\ncreateRoomScreen.SetActive(false);\nroomScreen.SetActive(false);\nerrorScreen.SetActive(false);\n}\n\npublic override void OnConnectedToMaster()\n{\nPhotonNetwork.JoinLobby();\nloadingText.text = \"Joining Lobby...\";\n}\n\npublic override void OnJoinedLobby()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n\npublic void OpenRoomCreate()\n{\nCloseMenus();\ncreateRoomScreen.SetActive(true);\n}\n\npublic void CreateRoom()\n{\nif (!string.IsNullOrEmpty(roomInputField.text))\n{\nRoomOptions options = new RoomOptions();\noptions.MaxPlayers = 8;\nPhotonNetwork.CreateRoom(roomInputField.text, options);\nCloseMenus();\nloadingText.text = \"Creating Room...\";\nloadingScreen.SetActive(true);\n}\n}\n\npublic override void OnJoinedRoom()\n{\nCloseMenus();\nroomScreen.SetActive(true);\n\nroomNameText.text = PhotonNetwork.CurrentRoom.Name;\n}\n\npublic override void OnCreateRoomFailed(short returnCode, string message)\n{\nerrorText.text = \"Failed to create room: \" + message;\nCloseMenus();\nerrorScreen.SetActive(true);\n}\n\npublic void CloseErrorScreen()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n\npublic void LeaveRoom()\n{\nPhotonNetwork.LeaveRoom();\nCloseMenus();\nloadingText.text = \"Leaving Room...\";\nloadingScreen.SetActive(true);\n}\n\npublic override void OnLeftRoom()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/making-a-level/","title":"Making A Level","text":""},{"location":"fps-multiplayer/making-a-level/#setting-up-a-level","title":"Setting Up A Level","text":"<ul> <li>Save the current scene by going to <code>File &gt; Save As</code> and giving it a new name, <code>Map 1</code>.</li> <li>Delete the existing environment model in the scene.</li> <li>Drag and drop the<code>Future City/futuristic low poly city</code> model into the scene to add it as the new environment.</li> <li>Deactivate the <code>camera</code> attached to the <code>Future City</code> model.</li> <li>Deactivate the point lights attached to the Future City model.</li> <li>Add <code>mesh colliders</code> to each object in the <code>Future City</code> model by selecting each object (excluding the camera and point lights), going to <code>Add Component &gt; Physics &gt; Mesh Collider</code>.</li> <li>Adjust the scale of the <code>Future City</code> model to <code>0.5</code> on all axes by selecting the <code>Future City</code> model and changing the scale values in the Inspector.</li> <li>Change the layer of all objects in the <code>Future City</code> model to <code>ground</code></li> <li>Save the scene and play the game to test the changes made.</li> </ul>"},{"location":"fps-multiplayer/making-a-level/#spawning-at-different-points","title":"Spawning At Different Points","text":"<ul> <li>Create an empty object called <code>Spawn Manager</code>.</li> <li>Duplicate the <code>Player</code> object and remove the viewpoint and the ground check point from the duplicated player object to be used as a spawn point.</li> <li>Rename the duplicated player object to <code>Spawn Point</code>.</li> <li>Remove the <code>Player Controller</code> script and the <code>Character Controller</code> components from the <code>Spawn Point</code>.</li> <li>Place the <code>Spawn Points</code> at various locations in the game, making sure they are not inside other objects or halfway through the floor.</li> <li>Create a script called <code>Spawn Manager</code> and attach it to the <code>Spawn Manager</code> game object.</li> <li>Add all the <code>Spawn Points</code> as children to the <code>Spawn Manager</code> game object.</li> <li>Create a <code>public Transform[] spawnPoints</code> in the <code>SpawnManager</code> script to reference all the spawn points.</li> <li>In the start function of the <code>SpawnManager</code> script, deactivate all the spawn points objects so they are not visible in the game.</li> <li>Create a public function called <code>GetSpawnPoint</code> in the <code>SpawnManager</code> script that randomly picks a spawn point from the <code>spawn points</code> array.</li> <li>Create a temporary new transform called <code>spawnPoint</code> in the <code>PlayerController</code> script.</li> <li>In the <code>PlayerController</code> script, use the <code>GetSpawnPoint()</code> method from the <code>SpawnManager</code> to get a random spawn point.</li> <li>Set the position and rotation of the player to the transform of the random spawn point.</li> </ul> <p><code>PlayerController.cs</code></p> <pre><code>void Start()\n{\n//..\n\n// Randomly spawn player\nTransform spawnPoint = SpawnManager.Instance.GetSpawnPoint();\ntransform.position = spawnPoint.position;\ntransform.rotation = spawnPoint.rotation;\n}\n</code></pre> <p><code>SpawnManager.cs</code></p> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpawnManager : MonoBehaviour\n{\npublic static SpawnManager Instance;\npublic Transform[] spawnPoints;\n\nprivate void Awake()\n{\nif (Instance != null)\n{\nDestroy(gameObject);\nreturn;\n}\nInstance = this;\nDontDestroyOnLoad(gameObject);\n}\n\n// Start is called before the first frame update\nvoid Start()\n{\nforeach(Transform spawnPoint in spawnPoints)\n{\nspawnPoint.gameObject.SetActive(false);\n}\n}\n\npublic Transform GetSpawnPoint()\n{\nreturn spawnPoints[Random.Range(0, spawnPoints.Length)];\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/making-a-level/#selecting-weapon-with-number-keys","title":"Selecting Weapon With Number Keys","text":"<ul> <li>Open the Player Controller script in Unity.</li> <li>Scroll down to where the weapon switching code is located and add the following:</li> </ul> <pre><code>for (int i = 0; i &lt; allGuns.Length; i++)\n{\nif (Input.GetKeyDown(KeyCode.Alpha1 + i))\n{\nselectedGun = i;\nSwitchGun();\n}\n}\n</code></pre> <ul> <li>Save the <code>PlayerController</code> script and test the game. Players should now be able to switch between weapons using number keys instead of the scroll wheel.</li> </ul>"},{"location":"fps-multiplayer/overview/","title":"FPS Multiplayer","text":"<p>Here is where I plan to document the steps required to build an FPS multiplayer game in Unity as a follow along with the Udemy course Learn To Create An Online Multiplayer Game In Unity</p>"},{"location":"fps-multiplayer/overview/#key-objectives","title":"Key Objectives","text":"<ul> <li>Learn how to build a multi-user environment in Unity using Photon</li> <li>Further develop my skills in C#</li> <li>Learn to create a fun FPS shooter</li> </ul>"},{"location":"fps-multiplayer/player-health-system/","title":"Players Health System","text":""},{"location":"fps-multiplayer/players-on-network/","title":"Players On The Network","text":""},{"location":"fps-multiplayer/players-on-network/#setting-up-player-for-the-network","title":"Setting Up Player For The Network","text":"<p>Here are the steps to set up a player prefab to work with Photon Networking and instantiate it with multiple players:</p> <ul> <li>In Unity, open the map scene with your player GameObject.</li> <li>Create a folder named <code>Resources</code> in the <code>Assets</code> folder. This folder is <code>reserved</code> for specific purposes, like loading prefabs at runtime.</li> <li>Turn the <code>Player</code> GameObject into a <code>prefab</code> by dragging it into the <code>Resources</code> folder.</li> <li>Open the <code>Player</code> prefab and add a <code>Photon View</code> component to it. This component allows the object to be tracked by Photon and sends information to other players on the network.</li> <li>In the <code>Photon View</code> component, change the <code>Observed Components</code> setting from <code>Auto Find</code> to <code>Manual.</code> This allows you to choose the specific components you want to send over the network.</li> <li>Drag the <code>Player</code> GameObject into the <code>Observed Components</code> slot.</li> <li>In the Photon Transform View component, deselect the <code>Synchronize Scale</code> option, as the player's scale will not change during gameplay. This reduces the amount of network data being sent, improving performance.</li> <li>Save the <code>Player</code> prefab.</li> </ul>"},{"location":"fps-multiplayer/players-on-network/#spawning-players","title":"Spawning Players","text":"<ul> <li>In the <code>Map 1</code> scene, create an empty GameObject and name it <code>Player Spawner</code> .</li> <li>In your <code>Scripts</code> folder, create a new C# script called <code>PlayerSpawner</code> and attach it to the <code>Player Spawner</code> GameObject.</li> <li>Add the following code in the <code>PlayerSpawner</code> script:</li> </ul> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Photon.Pun;\n\npublic class PlayerSpawner : MonoBehaviour\n{\npublic static PlayerSpawner instance;\n\nprivate void Awake()\n{\ninstance = this;\n}\n\npublic GameObject playerPrefab;\nprivate GameObject player;\n\n// Start is called before the first frame update\nvoid Start()\n{\nif (PhotonNetwork.IsConnected)\n{\nSpawnPlayer();\n}\n}\n\npublic void SpawnPlayer()\n{\nTransform spawnPoint = SpawnManager.instance.GetSpawnPoint();\nplayer = PhotonNetwork.Instantiate(playerPrefab.name, spawnPoint.position, spawnPoint.rotation);\n}\n}\n</code></pre> <ul> <li>In the <code>Launcher</code> script, remove the player spawning logic in the <code>Start()</code> method:</li> </ul> <pre><code>void Start()\n{\n//..\n- Transform spawnPoint = SpawnManager.instance.GetSpawnPoint();\n- transform.position = spawnPoint.position;\n- transform.rotation = spawnPoint.rotation;\n}\n</code></pre>"},{"location":"fps-multiplayer/players-on-network/#controlling-one-player","title":"Controlling One Player","text":"<p>Here is a summary of the steps to make it so players can only control themselves and not anybody else:</p> <ul> <li>Open your <code>PlayerControl</code> script.</li> <li>Add `using Photon.Pun; at the top of the script to include the Photon namespace.</li> <li>Replace <code>MonoBehaviour</code> with <code>MonoBehaviourPunCallbacks</code> to access the Photon systems.</li> <li>Modify the <code>LateUpdate</code> function to update the camera's position only if the player is in control.</li> <li>At the start of the <code>Update</code> function, add <code>if (photonView.IsMine)</code> to only execute the move input and other actions if the player is in control.</li> <li>Save the script and go back to Unity.</li> <li>Build and test the game to ensure that each player can only control their own character and not other players.</li> </ul> <p><code>PlayerControl.cs</code></p> <pre><code>using Photon.Pun\n\npublic class PlayerController : MonoBehaviourPunCallbacks\n{\n//..\nvoid Update()\n{\n// Check if we have authority over the current player\nif (photonView.IsMine)\n{\n//..\n}\n}\n\nvoid LateUpdate()\n{\n// Check if we have authority over the current player\nif (photonView.IsMine)\n{\n//..\n}\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/players-on-network/#auto-returning-to-menu","title":"Auto Returning To Menu","text":"<ul> <li>Create a new script called <code>MatchManager</code> in the Scripts folder.</li> <li>In the scene, create an empty GameObject named <code>MatchManager</code> and attach the MatchManager script to it.</li> <li>Open the MatchManager script and add the following:</li> </ul> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Photon.Pun;\nusing UnityEngine.SceneManagement;\n\npublic class MatchManager : MonoBehaviour\n{\npublic static MatchManager instance;\n\nprivate void Awake()\n{\ninstance = this;\n}\n\n// Start is called before the first frame update\nvoid Start()\n{\n// If we are not connected to the network, load the main menu\nif (!PhotonNetwork.IsConnected)\n{\nSceneManager.LoadScene(0);\n}\n}\n}\n</code></pre> <ul> <li>Save the script and test it in Unity to ensure that the main menu loads when not connected to the network.</li> <li>To fix the lighting issue in the editor, stop the game, then open <code>Window &gt; Rendering &gt; Lighting</code>.</li> <li>Dock the Lighting window next to the Inspector.</li> <li>Create new lighting settings for general use in your game by clicking <code>New Lighting Settings</code> and saving it in the <code>Assets</code> folder.</li> <li>With the scene open, scroll down in the Lighting window and click <code>Generate Lighting</code> to examine and apply the lighting settings to the scene.</li> <li>Save the scene and test the game again to see the improved lighting in the editor.</li> </ul>"},{"location":"fps-multiplayer/players-on-network/#showing-player-impacts","title":"Showing Player Impacts","text":"<ul> <li>Create a <code>Player Hit Impact</code> effect prefab by duplicating an existing <code>Bullet Impact</code> prefab and modifying it to suit the game's theme.</li> <li>Add the new prefab to the <code>Resources</code> folder.</li> <li>Add a <code>DestroyOverTime</code> script to the prefab so it destroys itself after a specified time.</li> <li>Add a <code>Photon View</code> component to the prefab and set it up to synchronize the position.</li> <li>In the <code>PlayerController</code> script, add a <code>public GameObject playerHitImpact</code> prefab.</li> <li>Assign the <code>Player tag</code> to the player object in Unity.</li> <li>Modify the shoot function in the Player Controller script to check if the object hit has the Player tag. If it does, instantiate the player hit impact effect at the hit point using Photon Network. If not, instantiate the normal bullet impact effect.</li> <li>Add a debug log to display the name of the player being hit (this is for testing purposes only and can be removed later).</li> </ul> <p><code>PlayerController.cs</code></p> <pre><code>public GameObject playerHitImpact;\n\nprivate void Shoot() {\n//..\n\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\n// ..\nif (hit.collider.gameObject.CompareTag(\"Player\"))\n{\nDebug.Log(\"We hit \" + hit.collider.gameObject.GetPhotonView().Owner.NickName + \"!\");\nPhotonNetwork.Instantiate(playerHitImpact.name, hit.point, Quaternion.identity);\n}\nelse\n{\nGameObject bulletImpactObject = Instantiate(bulletImpact, hit.point + (hit.normal * 0.02f), Quaternion.LookRotation(hit.normal, Vector3.up));\nDestroy(bulletImpactObject, 5f);\n}\n}\n}\n</code></pre> <p><code>DestroyOverTime.cs</code></p> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class DestroyOverTime : MonoBehaviour\n{\npublic float lifetime = 1.5f;\n\n// Start is called before the first frame update\nvoid Start()\n{\nDestroy(gameObject, lifetime);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/players-on-network/#shooting-with-rpcs","title":"Shooting With RPCs","text":"<p>In order to send information across the network to let others know when a player has been hit:</p> <ul> <li>In the <code>PlayerController</code> script, create a new public function called <code>DealDamage</code> below the <code>Shoot</code> function.</li> <li>Before the <code>DealDamage</code> function, type in square brackets and <code>PunRPC</code> to make it a Photon Remote Procedure Call (RPC). This will allow the function to run at the same time on every copy of the player on the network.</li> <li>Inside the <code>DealDamage</code> function, add a debug log that says <code>I've been hit</code> for now.</li> <li>Modify the <code>DealDamage</code> function to take in a string parameter called <code>Damager</code> and update the debug log to include the damager's name.</li> <li>When shooting, get the PhotonView component of the object that was hit.</li> <li>Call the <code>DealDamage</code> RPC function using the PhotonView.RPC method, passing in the function's name as a string, the target (in this case, <code>RpcTarget.All</code>), and the shooter's nickname as the <code>Damager</code> parameter.</li> <li>Save the script, build and run the game to test the functionality.</li> </ul> <p>Now, when shooting a player, the <code>I've been hit</code> message will be displayed along with the name of the player who inflicted the damage. This basic shooting functionality will serve as a foundation for further development, such as updating player health and handling player death.</p> <pre><code>[PunRPC]\npublic void DealDamage(string damager)\n{\n// This will be sent to every player\nDebug.Log(\"I've been hit by \" + damager);\n}\n\nprivate void Shoot()\n{\n//..\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\n// ..\nif (hit.collider.gameObject.CompareTag(\"Player\"))\n{\n// ..\nhit.collider.gameObject.GetPhotonView().RPC(\"DealDamage\", RpcTarget.All, photonView.Owner.NickName); ;\n}\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/players-on-network/#taking-hits","title":"Taking Hits","text":"<p>To create a more interesting shooting interaction, follow these steps to implement a \"TakeDamage\" function and deactivate the player when they are hit:</p> <ul> <li>In the <code>PlayerController</code> script, create a new public function called <code>TakeDamage</code> below the <code>DealDamage</code> function.</li> <li>Make the <code>TakeDamage</code> function take a string parameter called <code>Damager</code>. Later on, you can also add the amount of damage and more specific references to your characters.</li> <li>Move the debug log from the <code>DealDamage</code> function to the <code>TakeDamage</code> function, and change the message to include the name of the PhotonView owner being hit by the damager.</li> <li>In the <code>DealDamage</code> function, call the <code>TakeDamage</code> function, passing on the damager information.</li> <li>In the <code>TakeDamage</code> function, add a line to deactivate the player's GameObject by calling <code>gameObject.SetActive(false)</code>.</li> <li>Save the script, build, and run the game to test the functionality.</li> </ul> <p>Now, when a player is shot, their GameObject will be deactivated, and the debug log will display which player has been hit by the damager. In the future, you can enhance this functionality by removing the player from the game and respawning them after a certain period.</p> <pre><code>[PunRPC]\npublic void DealDamage(string damager)\n{\nTakeDamage(damager);\n}\n\npublic void TakeDamage(string damager)\n{\nDebug.Log(photonView.Owner.NickName + \" has been hit by \" + damager);\ngameObject.SetActive(false);\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/","title":"Shooting &amp; Weapons","text":""},{"location":"fps-multiplayer/shooting-weapons/#shooting","title":"Shooting","text":"<ul> <li>In order for the <code>player</code> to shoot, add the following in the <code>PlayerController</code> script:</li> </ul> <pre><code>void Update() {\n// ..\n\n// Shoot if player left clicks\nif (Input.GetMouseButtonDown(0)) {\nShoot();\n}\n\n// Handle the mouse in windowed mode\n// ..\n}\n\nprivate void Shoot() {\n// Create a new ray that goes from the center of the screen outwards.\nRay ray = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));\n\n// Set the origin of the ray to the position of the player's camera.\nray.origin = playerCamera.transform.position;\n\n// If the raycast hits an object in the scene...\n// out passes by reference allowing 'hit' to be populated with return values\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\n// ...output the name of the object to the console.\nDebug.Log(\"We hit \" + hit.collider.gameObject.name);\n}\n}\n</code></pre> <ul> <li>Add a <code>cube</code> as a child of the <code>View Point</code> to represent the <code>Gun Placeholder</code></li> <li>Add a <code>material</code> to the <code>Gun Placeholder</code></li> <li>Remove the <code>Box Colliders</code> from both the <code>Goggles</code> and the <code>Gun Placeholder</code></li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#creating-impact-effect","title":"Creating Impact Effect","text":""},{"location":"fps-multiplayer/shooting-weapons/#bullet-impact","title":"Bullet Impact","text":"<ul> <li>Create a <code>quad</code> object in the game world to represent the bullet impact.</li> <li>Create a empty parent object called <code>Bullet Impact</code> and add the <code>quad</code> to it</li> <li>Duplicate the <code>quad</code> object and rotate it <code>180</code> degrees so quad has two sides</li> <li>Create a material for the quad called <code>Bullet Impact</code> and apply an image from the <code>Art</code> folder called <code>Bullet Impact</code> to it to give it a more realistic appearance.</li> <li>Change the <code>Rendering Mode</code> to <code>Fade</code></li> <li>Apply the <code>material</code> to both sides of the <code>quads</code></li> <li>Change the scale of the <code>Bullet Impact</code> to <code>(0.25, 0.25, 0.25)</code></li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#particle-system","title":"Particle System","text":"<ul> <li>Right-click on the <code>Bullet Impact</code> object in the Hierarchy window and select <code>Effects</code> -&gt; <code>Particle System</code> from the context menu. This will add a particle system component to the bullet impact object.</li> <li>In the Particle System component, change the <code>Start Size</code> to 0.1 to create small particles.</li> <li>Change the <code>Shape</code> to <code>Sphere</code> to create a circular impact area.</li> <li>Adjust the <code>Radius</code> to <code>0.01</code> to control the size of the impact area.</li> <li>Change the <code>Duration</code> to 1 to control how long the particles stay visible.</li> <li>Change the <code>Start Lifetime</code> to 1 to control how long each particle lasts.</li> <li>Change the <code>Start Speed</code> to a low value, such as 0.1, to make the particles move slowly.</li> <li>Under <code>Emission</code>, change the <code>Rate Over Time</code> to 0 to stop the particle system from continuously emitting particles.</li> <li>Under <code>Bursts</code>, click on the <code>+</code> button to add a burst of particles.</li> <li>Set the <code>Count</code> to 25 to create 25 particles in the burst.</li> <li>Change the <code>Start Color</code> to <code>Random Between Two Colors</code>.</li> <li>Choose a light gray color for the first color and a dark gray color for the second color to match the bullet impact material.</li> <li>Under <code>Size Over Lifetime</code>, click on the curve axis and select <code>Size</code> and select a curve that reduces the size over time to create a fading effect for the particles.</li> <li>Turn off the <code>Looping</code> option to ensure that the particle system only emits particles once.</li> <li>Save the bullet impact object as a prefab in the <code>Prefabs</code> folder so that it can be easily reused in the game.</li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#placing-impacts","title":"Placing Impacts","text":"<ul> <li>Create a public game object <code>bullet impact</code> reference in the <code>PlayerController</code> script.</li> <li>Make sure the <code>bullet impact</code> reference is assigned correctly on the player.</li> <li>In the shoot function, use the <code>instantiate</code> command to create a copy of the <code>bullet impact</code> game object.</li> <li>Set the position of the impact object to the hit point using the <code>hit.point</code> command.</li> <li>Set the rotation of the impact object to the surface normal using the <code>Quaternion.LookRotation(hit.normal, Vector3.up)</code> command.</li> <li>To prevent flickering, move the impact object slightly away from the surface using the <code>hit.normal * 0.002f</code> command.</li> <li>Destroy the impact object after a certain amount of time using the <code>Destroy(bulletImpactObject, 5f)</code> command.</li> <li>Remove the <code>mesh collider</code> from the impact object prefab to prevent layering of impact objects.</li> </ul> <pre><code>public GameObject bulletImpact;\n\nprivate void Shoot()\n{\n// ..\n\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\nGameObject bulletImpactObject = Instantiate(bulletImpact, hit.point + (hit.normal * 0.02f), Quaternion.LookRotation(hit.normal, Vector3.up));\nDestroy(bulletImpactObject, 5f);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#automatic-firing","title":"Automatic Firing","text":"<ul> <li>In the <code>PlayerController</code> script, add a public float variable named <code>timeBetweenShots</code> and a private float variable named <code>shotCounter</code>.</li> <li>Set the default value of <code>timeBetweenShots</code> to 0.1 (or any other desired value).</li> <li>In the shooting code section, after shooting a bullet, set <code>shotCounter</code> to <code>timeBetweenShots</code>.</li> <li>Check if the left mouse button is still being held down using the <code>GetMouseButton</code> function.</li> <li>If the left mouse button is still being held down, decrement <code>shotCounter</code> by <code>Time.deltaTime</code>.</li> <li>Check if <code>shotCounter</code> is less than or equal to zero. If it is, shoot a bullet again and set <code>shotCounter</code> back to <code>timeBetweenShots</code>.</li> <li>To avoid repeating code, use the <code>shoot()</code> function that was created earlier for shooting bullets.</li> </ul> <pre><code>public float timeBetweenShots = 0.1f;\nprivate float shotCounter;\n\nvoid Update() {\n//..\n\n// Check if left mouse button is still held down\nif (Input.GetMouseButton(0))\n{\nshotCounter -= Time.deltaTime;\nif (shotCounter &lt;= 0)\n{\nShoot();\nshotCounter = timeBetweenShots;\n}\n}\n}\n\nprivate void Shoot() {\n//..\n\nshotCounter = timeBetweenShots;\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#weapon-overheating","title":"Weapon Overheating","text":"<ul> <li>Open up the player controller script and add the following public floats at the top:</li> <li>maxHeatValue: the maximum heat level that the gun can reach before overheating. Set it to 10.</li> <li>heatPerShot: the amount of heat that is added to the gun's heat level every time a shot is fired. Set it to 1.</li> <li>coolingRate: the rate at which the gun's heat level decreases when it's not being fired. Set it to 4.</li> <li>overheatedCoolRate: the rate at which the gun's heat level decreases when it's overheated. Set it to 5.</li> <li>Add the following private variables:</li> <li>heatCounter: a float that will keep track of the gun's current heat level.</li> <li>overheated: a bool that will keep track of whether the gun is currently overheated or not.</li> <li>In the shoot function, add the following lines of code to increase the heat counter:</li> <li>heatCounter += heatPerShot;</li> <li>Check if heatCounter is greater than or equal to maxHeatValue. If it is, set heatCounter to maxHeatValue and set overheated to true.</li> <li>Before shooting, add a check to see if the gun is currently overheated. If it is, the gun cannot fire.</li> <li>After shooting, decrease the heatCounter by coolingRate * Time.deltaTime if the gun is not overheated. If it is overheated, decrease it by overheatedCoolRate * Time.deltaTime.</li> <li>Add a check to see if the heatCounter has decreased to zero. If it has, set overheated to false and set heatCounter to zero.</li> <li>Set up a way for the player to see the gun's heat level visually in the game. This can be done by creating a UI element that displays the heat level as a bar or number. Update the UI element every frame to reflect the current heat level.</li> <li>That's it! With these steps, you should have a functioning ammo system that prevents players from shooting forever and encourages tactical gameplay.</li> </ul> <pre><code>public float maxHeatValue = 10f;\npublic float heatPerShot = 1f;\npublic float coolingRate = 4f;\npublic float overheatedCoolRate = 5f;\nprivate float heatCounter;\nprivate bool overheated;\n\nvoid Update()\n{\n// ..\n\nif (!overheated)\n{\n// Shoot if player left clicks\n// ..\nheatCounter -= coolingRate * Time.deltaTime;\n}\nelse\n{\nheatCounter -= overheatedCoolRate * Time.deltaTime;\nif (heatCounter &lt; 0) overheated = false;\n}\nif (heatCounter &lt; 0) heatCounter = 0f;\n\n//..\n}\n\nprivate void Shoot()\n{\n//..\n\nheatCounter += heatPerShot;\nif (heatCounter &gt;= maxHeatValue)\n{\nheatCounter = maxHeatValue;\noverheated = true;\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#overheated-indicator","title":"Overheated Indicator","text":"<ul> <li>Set up the display resolution for the game to Full HD.</li> <li>Create a <code>Canvas</code> and set it up to match the Full HD resolution using Canvas Scalar as well as set <code>Match</code> to <code>Height</code></li> <li>Add a <code>TextMeshPro</code> object to the canvas with the words <code>Weapon Overheated</code> and customize its appearance.</li> <li>Create a <code>UIController</code> script and attach it to the <code>Canvas</code>.</li> <li>In the <code>UIController</code> script, make in a <code>singleton</code> by creating a public static instance of the script and assign it to the UI controller object in the <code>Awake()</code> method.</li> <li>Use the <code>UIController</code> instance in other scripts to access the TextMeshPro object and modify its - appearance or visibility as needed.</li> <li>Add code to turn off the overheated message when the gun is no longer overheated.</li> </ul> <p><code>UIController.cs</code></p> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\n\npublic class UIController : MonoBehaviour\n{\npublic static UIController Instance;\npublic TextMeshProUGUI overheatedMessage;\n\nprivate void Awake()\n{\nif (Instance != null)\n{\nDestroy(gameObject);\nreturn;\n}\nInstance = this;\nDontDestroyOnLoad(gameObject);\n}\n}\n</code></pre> <p><code>PlayerController.cs</code></p> <pre><code>void Update() {\n//..\n\nif (heatCounter &lt; 0)\n{\noverheated = false;\nUIController.Instance.overheatedMessage.gameObject.SetActive(false);\n}\n}\n\nprivate void Shoot() {\nif (heatCounter &gt;= maxHeatValue)\n{\nheatCounter = maxHeatValue;\noverheated = true;\nUIController.Instance.overheatedMessage.gameObject.SetActive(true);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#displaying-current-weapon-heat","title":"Displaying Current Weapon Heat","text":"<ul> <li>Right-click on the <code>canvas</code></li> <li>Add a <code>UI slider</code> and name it <code>Temp Slider</code></li> <li>Remove the slide area and background from the <code>slider</code></li> <li>Remove the source image for the fill and change its color to orange</li> <li>Drag the edges of the <code>slider</code> box to match the anchor points of the holder object</li> <li>Add a UI image to show the endpoint of the <code>slider</code></li> <li>Add an outline to the <code>slider</code> and image</li> <li>Add a UI text to display the label <code>Weapon Temp</code></li> <li>Set the anchor point of the <code>slider</code> to the bottom right corner</li> <li>Set the anchor point of the <code>text</code> to the bottom right corner</li> <li>Create a reference to the <code>slider</code> in the UI controller script</li> <li>In the <code>UIController</code> script, set the maximum value of the slider to be equal to the max heat value</li> <li>Update the value of the <code>slider</code> in the <code>UIController</code> script after handling the shooting and overheating</li> <li>Set the default value of the <code>slider</code> to zero on the canvas</li> <li>Play the game to see the <code>slider</code> in action.</li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#adding-a-crosshair","title":"Adding A Crosshair","text":"<ul> <li>Open the Unity Editor and navigate to the <code>Canvas</code> in the Hierarchy window.</li> <li>Right-click on the <code>Canvas</code> and select <code>UI &gt; Image</code> to add a new UI Image object to the <code>Canvas</code>.</li> <li>Rename the new object to <code>Crosshairs</code>.</li> <li>In the Inspector window, change the Source Image of the <code>Crosshairs</code> object to the desired crosshair image in the <code>Assets</code> folder.</li> <li>Set the <code>Anchor Presets</code> to the middle of the <code>Canvas</code> to keep the crosshairs centered.</li> <li>Set the color of the crosshairs to a darker color than white to make it more visible.</li> <li>Set the scale of the crosshairs to <code>2x2</code> to make it bigger and more visible.</li> <li>Adjust the position of the crosshairs as desired.</li> <li>Save the changes and run the game to see the new crosshairs in action.</li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#setting-up-multiple-weapons","title":"Setting Up Multiple Weapons","text":"<ul> <li>The next step is to add the ability to switch between weapons in the game.</li> <li>Start by setting up empty components on the player. Select the Viewpoint and right-click to create an empty child called <code>Gun Holder</code>. Create three more empty children called <code>Gun 1</code>, <code>Gun 2</code> and <code>Gun 3</code> under <code>Gun Holder</code>.</li> <li>Add three 3D models for each gun. Drag them from the <code>models</code> folder in the <code>assets</code>, and make them children of each gun. The 3D models should face the wrong way, so select each model and rotate them 180 degrees on the y-axis.</li> <li>Move the <code>Gun Holder</code> objects to the correct position, and move the guns slightly to the side.</li> <li>Create a new script in the scripts folder and name it <code>Gun</code>. Remove the <code>Start()</code> and <code>Update()</code> methods and add a <code>public bool isAutomatic</code>, a <code>public float timeBetweenShots = 0.1f</code>, and a <code>public float heatPerShot = 1f</code> that will be added with each shot. Save the script.</li> <li>Add the Gun script to each gun object and set the properties for each gun. The machine gun and rifle will be automatic, while the pistol will do 2 heat per shot. The rifle will fire slower and add more heat than the other guns.</li> </ul> <p><code>Gun.cs</code></p> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Gun : MonoBehaviour\n{\npublic bool isAutomatic;\npublic float timeBetweenShots = 0.1f;\npublic float heatPerShot = 1f;\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#switching-weapons","title":"Switching Weapons","text":"<ul> <li>In the player controller script, add a public gun array called <code>allGuns</code> and a private integer called <code>selectedGun</code>.</li> <li>In the Unity inspector, add the guns you want to use to the <code>allGuns</code> list.</li> <li>In the player controller script, in the Update function, add a conditional statement to check if the mouse scroll wheel is being scrolled up or down. If it's being scrolled up, increment the <code>selectedGun</code> value by one. If it's being scrolled down, decrement the <code>selectedGun</code> value by one.</li> <li>Add a new function called <code>switch gun</code> that deactivates all guns in the <code>allGuns</code> list except for the one selected by the <code>selectedGun</code> value.</li> <li>In the Update function, call the <code>switch gun</code> function after changing the <code>selectedGun</code> value.</li> <li>In the Start function, call the <code>switch gun</code> function to activate the first gun in the <code>allGuns</code> list.</li> <li>Play the game and use the scroll wheel to switch between guns.</li> </ul> <pre><code>public Gun[] allGuns;\nprivate int selectedGun;\n\nvoid Start() {\n//..\n\nSwitchGun()\n}\n\nvoid Update() {\n//..\n\n// Handle gun selection\nif (Input.GetAxisRaw(\"Mouse ScrollWheel\") &gt; 0f)\n{\nselectedGun++;\nif (selectedGun &gt;= allGuns.Length) selectedGun = 0;\nSwitchGun()\n}\nif (Input.GetAxisRaw(\"Mouse ScrollWheel\") &lt; 0f)\n{\nselectedGun--;\nif (selectedGun &lt; 0) selectedGun = allGuns.Length - 1;\nSwitchGun()\n}\n\n// Handle the mouse in windowed mode\n// ..\n}\n\nvoid SwitchGun()\n{\nforeach(Gun gun in allGuns)\n{\n// Deactivate all guns\ngun.gameObject.SetActive(false);\n}\n// Activate the selected gun\nallGuns[selectedGun].gameObject.SetActive(true);\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#making-the-weapons-function-correctly","title":"Making The Weapons Function Correctly","text":"<ul> <li>Open the <code>PlayerController</code> script in the editor.</li> <li>Scroll down to the <code>Shoot()</code> function.</li> <li>Comment out any areas where default values are used by adding two slashes at the beginning of the line.</li> <li>Replace the default values with values from the <code>selectedGun</code> in the <code>allGuns</code> array. For example, instead of using the default <code>timeBetweenShots</code> value, get the <code>timeBetweenShots</code> value from the <code>selectedGun</code> in the <code>allGuns</code> array.</li> <li>Use the <code>isAutomatic</code> check to determine whether the player is allowed to continue firing.</li> <li>Save the changes to the script.</li> <li>Test the changes by playing the game and switching between the different weapons. Ensure that each weapon behaves differently in terms of firing rate and other attributes.</li> </ul> <pre><code>// public float timeBetweenShots = 0.1f;\n// public float heatPerShot = 1f;\n\nvoid Update() {\n//..\n\n// Check if left mouse button is still held down\n- if (Input.GetMouseButton(0)) { /*..*/ }\n+ if (Input.GetMouseButton(0) &amp;&amp; allGuns[selectedGun].isAutomatic) { /*..*/ }\n}\n\nvoid Shoot() {\n//..\n\n- shotCounter = timeBetweenShots;\n+ shotCounter = allGuns[selectedGun].timeBetweenShots;\n\n- heatCounter += heatPerShot;\n+ heatCounter += allGuns[selectedGun].heatPerShot;\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#muzzle-flashes","title":"Muzzle Flashes","text":"<ul> <li>Open the Models folder and drag the Muzzle Flash model into the scene at position (0,0,0).</li> <li>Make the Muzzle Flash a child of each gun model (e.g. Pistol, Machine Gun, Rifle) and rotate it 180 degrees.</li> <li>Assign each Muzzle Flash object to a public GameObject variable in the gun script, e.g. <code>public GameObject muzzleFlash</code>.</li> <li>Deactivate all Muzzle Flash objects by default in the scene.</li> <li>Add a <code>public float muzzleDisplayTime</code> as well as a <code>private float muzzleCounter</code></li> <li>In the <code>Shoot()</code> method, activate the Muzzle Flash when shooting a gun as well as reset the muzzleCounter:</li> </ul> <pre><code>allGuns[selectedGun].muzzleFlash.SetActive(true);\nmuzzleCounter = muzzleDisplayTime;\n</code></pre> <ul> <li>Add a timer to automatically deactivate the Muzzle Flash after a short period of time:</li> </ul> <pre><code>if (allGuns[selectedGun].muzzleFlash.activeInHierarchy)\n{\nmuzzleCounter -= Time.deltaTime;\nif (muzzleCounter &lt;= 0) allGuns[selectedGun].muzzleFlash.SetActive(false);\n}\n</code></pre> <ul> <li>Assign a value to the <code>muzzleDisplayTime</code> variable, which determines how long the Muzzle Flash stays active. You can calculate this value based on your target frame rate, e.g. <code>1 / 60</code> for a 60 fps game.</li> <li>Add a line of code to deactivate the Muzzle Flash whenever switching to a new weapon</li> </ul> <pre><code>void SwitchGun() {\n//..\nallGuns[selectedGun].muzzleFlash.SetActive(false);\n}\n</code></pre> <ul> <li>Test the game and adjust the Muzzle Flash timer and position as needed to achieve the desired effect.</li> </ul>"},{"location":"fps-multiplayer/shooting-weapons/#code","title":"Code","text":""},{"location":"fps-multiplayer/shooting-weapons/#guncs","title":"Gun.cs","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Gun : MonoBehaviour\n{\npublic bool isAutomatic;\npublic float timeBetweenShots = 0.1f;\npublic float heatPerShot = 1f;\npublic GameObject muzzleFlash;\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#playercontrollercs","title":"PlayerController.cs","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\npublic Transform viewPoint;\npublic float mouseSensitivity = 1f;\nprivate float verticalRotStore;\nprivate Vector2 mouseInput;\n\npublic bool invertLook;\n\npublic float moveSpeed = 5f;\npublic float runSpeed = 8f;\nprivate float activeMoveSpeed;\nprivate Vector3 moveDir, movement;\n\npublic CharacterController characterController;\nprivate Camera playerCamera;\n\npublic float jumpForce = 12f;\npublic float gravityModifier = 2.5f;\n\npublic Transform groundCheckpoint;\nprivate bool isGrounded;\npublic LayerMask groundLayers;\n\npublic GameObject bulletImpact;\n// public float timeBetweenShots = 0.1f;\nprivate float shotCounter;\n\npublic float maxHeatValue = 10f;\n// public float heatPerShot = 1f;\npublic float coolingRate = 4f;\npublic float overheatedCoolRate = 5f;\nprivate float heatCounter;\nprivate bool overheated;\n\npublic float muzzleDisplayTime;\nprivate float muzzleCounter;\n\npublic Gun[] allGuns;\nprivate int selectedGun;\n\n// Start is called before the first frame update\nvoid Start()\n{\n// CursorLockMode.Locked value sets the lock state of the cursor to locked,\n// which hides the cursor and locks it to the center of the game window.\nCursor.lockState = CursorLockMode.Locked;\nplayerCamera = Camera.main;\n\nUIController.Instance.weaponTempSlider.maxValue = maxHeatValue;\n\nSwitchGun();\n}\n\n// Update is called once per frame\nvoid Update()\n{\n// Get the mouse input on the x and y axes and multiply it by a sensitivity value\nmouseInput = new Vector2(\nInput.GetAxisRaw(\"Mouse X\"),\nInput.GetAxisRaw(\"Mouse Y\")) * mouseSensitivity;\n\n// Set the rotation of the object to a new quaternion that has the same x and z angles as before,\n// but has the y angle increased by the mouse input on the x axis.\ntransform.rotation = Quaternion.Euler(\ntransform.rotation.eulerAngles.x,\ntransform.rotation.eulerAngles.y + mouseInput.x,\ntransform.rotation.eulerAngles.z);\n\nverticalRotStore = invertLook ? verticalRotStore - mouseInput.y : verticalRotStore + mouseInput.y;\nverticalRotStore = Mathf.Clamp(verticalRotStore, -60f, 60f);\n\nviewPoint.rotation = Quaternion.Euler(\nverticalRotStore,\nviewPoint.rotation.eulerAngles.y,\nviewPoint.rotation.eulerAngles.z);\n\nmoveDir = new Vector3(Input.GetAxisRaw(\"Horizontal\"), 0f, Input.GetAxisRaw(\"Vertical\"));\nactiveMoveSpeed = Input.GetKey(KeyCode.LeftShift) ? runSpeed : moveSpeed;\n\nfloat yVelocity = movement.y;\nmovement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized * activeMoveSpeed;\nmovement.y = yVelocity;\n\n// Reset the yVelocity if we are grounded\nif (characterController.isGrounded) movement.y = 0f;\n\n// Check if the player is grounded by using a Raycast\nisGrounded = Physics.Raycast(groundCheckpoint.position, Vector3.down, 0.25f, groundLayers);\n\n// Jumping\nif (Input.GetButtonDown(\"Jump\") &amp;&amp; isGrounded) movement.y = jumpForce;\n\n// Take into account gravity\nmovement.y += Physics.gravity.y * Time.deltaTime * gravityModifier;\ncharacterController.Move(movement * Time.deltaTime);\n\nif (allGuns[selectedGun].muzzleFlash.activeInHierarchy)\n{\nmuzzleCounter -= Time.deltaTime;\nif (muzzleCounter &lt;= 0) allGuns[selectedGun].muzzleFlash.SetActive(false);\n}\n\nif (!overheated)\n{\n// Shoot if player left clicks\nif (Input.GetMouseButtonDown(0))\n{\nShoot();\n}\n\n// Check if left mouse button is still held down\nif (Input.GetMouseButton(0) &amp;&amp; allGuns[selectedGun].isAutomatic)\n{\nshotCounter -= Time.deltaTime;\nif (shotCounter &lt;= 0)\n{\nShoot();\n}\n}\n\nheatCounter -= coolingRate * Time.deltaTime;\n}\nelse\n{\nheatCounter -= overheatedCoolRate * Time.deltaTime;\nif (heatCounter &lt; 0)\n{\noverheated = false;\nUIController.Instance.overheatedMessage.gameObject.SetActive(false);\n}\n}\nif (heatCounter &lt; 0) heatCounter = 0f;\n\nUIController.Instance.weaponTempSlider.value = heatCounter;\n\n// Handle gun selection\nif (Input.GetAxisRaw(\"Mouse ScrollWheel\") &gt; 0f)\n{\nselectedGun++;\nif (selectedGun &gt;= allGuns.Length) selectedGun = 0;\nSwitchGun();\n}\nif (Input.GetAxisRaw(\"Mouse ScrollWheel\") &lt; 0f)\n{\nselectedGun--;\nif (selectedGun &lt; 0) selectedGun = allGuns.Length - 1;\nSwitchGun();\n}\n\n\n// Handle the mouse in windowed mode\nif (Input.GetKeyDown(KeyCode.Escape)) Cursor.lockState = CursorLockMode.None;\nelse if (Cursor.lockState == CursorLockMode.None\n&amp;&amp; Input.GetMouseButtonDown(0)) Cursor.lockState = CursorLockMode.Locked;\n\n}\n\nvoid LateUpdate()\n{\nplayerCamera.transform.position = viewPoint.position;\nplayerCamera.transform.rotation = viewPoint.rotation;\n}\n\nprivate void Shoot()\n{\n// Create a new ray that goes from the center of the screen outwards.\nRay ray = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));\n\n// Set the origin of the ray to the position of the player's camera.\nray.origin = playerCamera.transform.position;\n\n// If the raycast hits an object in the scene...\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\n// ...output the name of the object to the console.\nDebug.Log(\"We hit \" + hit.collider.gameObject.name);\n\nGameObject bulletImpactObject = Instantiate(bulletImpact, hit.point + (hit.normal * 0.02f), Quaternion.LookRotation(hit.normal, Vector3.up));\nDestroy(bulletImpactObject, 5f);\n}\n\nshotCounter = allGuns[selectedGun].timeBetweenShots;\n\nheatCounter += allGuns[selectedGun].heatPerShot;\nif (heatCounter &gt;= maxHeatValue)\n{\nheatCounter = maxHeatValue;\noverheated = true;\nUIController.Instance.overheatedMessage.gameObject.SetActive(true);\n}\n\n// Muzzle flash\nallGuns[selectedGun].muzzleFlash.SetActive(true);\nmuzzleCounter = muzzleDisplayTime;\n}\n\nvoid SwitchGun()\n{\nforeach(Gun gun in allGuns)\n{\n// Deactivate all guns\ngun.gameObject.SetActive(false);\n}\n// Activate the selected gun\nallGuns[selectedGun].gameObject.SetActive(true);\n\nallGuns[selectedGun].muzzleFlash.SetActive(false);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/shooting-weapons/#uicontrollercs","title":"UIController.cs","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class UIController : MonoBehaviour\n{\npublic static UIController Instance;\npublic TextMeshProUGUI overheatedMessage;\npublic Slider weaponTempSlider;\n\nprivate void Awake()\n{\nif (Instance != null)\n{\nDestroy(gameObject);\nreturn;\n}\nInstance = this;\nDontDestroyOnLoad(gameObject);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/","title":"Room Browsing, Nicknames &amp; Starting a Game","text":""},{"location":"fps-multiplayer/starting-game/#laying-out-the-room-browser","title":"Laying Out The Room Browser","text":"<ul> <li>Duplicate the existing <code>Room Panel</code> and rename it to <code>Room Browser Panel</code>.</li> <li>Activate the <code>Room Browser Panel</code>, and update the title text to say <code>Find Room</code>.</li> <li>Create a scrollable area for the list of rooms by adding a <code>UI &gt; ScrollView</code> component to the <code>Room Browser Panel</code>.</li> <li>Adjust the size of the <code>ScrollView</code> to your desired dimensions (e.g., <code>600w x 700h</code>).</li> <li>Locate the content area inside the ScrollView, and adjust its size to be larger than the full size of the ScrollView (e.g <code>1000</code>). This will activate the scrollbars.</li> <li>Increase the scroll sensitivity of the <code>ScrollView</code> to make it scroll faster (e.g., <code>100</code>).</li> <li>Customize the appearance of the vertical scrollbar, such as changing its color and disabling the image on the scrollbar background.</li> <li>Add a <code>Button</code> prefab to the <code>Content</code> area of the <code>ScrollView &gt; Viewport</code>.</li> <li>Add a <code>Vertical Layout Group</code> component to the <code>Content</code> area to arrange the room buttons vertically with padding and spacing.</li> <li>Disable the <code>Force Expand Height</code> option in the <code>Vertical Layout Group</code> component.</li> <li>Add a <code>Content Size Fitter</code> component to the <code>Content</code> area and set it to <code>Vertical Fit: Min Size</code>. This will adjust the size of the <code>Content</code> area based on the number of buttons.</li> <li>Test the scrolling functionality by duplicating the room buttons and running the game. - Adjust the <code>ScrollView</code> settings as needed, such as changing the movement type to <code>Clamped</code> if you do not want the elastic bounce effect.</li> </ul>"},{"location":"fps-multiplayer/starting-game/#making-the-room-browser-work","title":"Making The Room Browser Work","text":"<ul> <li>Create a new script named <code>RoomButton</code> in the scripts folder.</li> <li>Attach the <code>RoomButton</code> script to the room button GameObject in your game.</li> <li>Open the RoomButton script in a code editor and add the following code:</li> </ul> <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing TMPro;\nusing Photon.Realtime;\n\npublic class RoomButton : MonoBehaviour\n{\npublic TextMeshProUGUI buttonText;\n\nprivate RoomInfo info;\n\npublic void SetButtonDetails(RoomInfo inputInfo)\n{\ninfo = inputInfo;\nbuttonText.text = info.Name;\n}\n}\n</code></pre> <ul> <li>Add the following code in the <code>Launcher</code> script to manage the rooms in the game:</li> </ul> <pre><code>public GameObject roomBrowserScreen;\npublic RoomButton theRoomButton;\nprivate List&lt;RoomButton&gt; allRoomButtons = new List&lt;RoomButton&gt;();\nprivate Dictionary&lt;string, RoomInfo&gt; cachedRoomsList = new Dictionary&lt;string, RoomInfo&gt;();\n\npublic void OpenRoomBrowser()\n{\nCloseMenus();\nroomBrowserScreen.SetActive(true);\n}\n\npublic void CloseRoomBrowser()\n{\nCloseMenus();\nmenuButtons.SetActive(true);\n}\n\n// This method is called when the room list is updated.\npublic override void OnRoomListUpdate(List&lt;RoomInfo&gt; roomList)\n{\n// Update the cached room list with the new room list information.\nUpdateCachedRoomList(roomList);\n}\n\n// This method updates the cached room list based on the provided room list.\npublic void UpdateCachedRoomList(List&lt;RoomInfo&gt; roomList)\n{\n// Iterate through the room list.\nfor (int i = 0; i &lt; roomList.Count; i++)\n{\nRoomInfo info = roomList[i];\n\n// If the room has been removed from the list, remove it from the cached room list.\nif (info.RemovedFromList)\n{\ncachedRoomsList.Remove(info.Name);\n}\nelse\n{\n// Otherwise, update or add the room to the cached room list.\ncachedRoomsList[info.Name] = info;\n}\n}\n\n// Update the room list buttons with the updated cached room list.\nRoomListButtonUpdate(cachedRoomsList);\n}\n\n// This method updates the room list buttons based on the provided cached room list.\nvoid RoomListButtonUpdate(Dictionary&lt;string, RoomInfo&gt; cachedRoomList)\n{\n// Clean up existing room buttons.\nforeach (RoomButton rb in allRoomButtons)\n{\nDestroy(rb.gameObject);\n}\nallRoomButtons.Clear();\ntheRoomButton.gameObject.SetActive(false);\n\n// Iterate through the cached room list and create new room buttons.\nforeach (KeyValuePair&lt;string, RoomInfo&gt; roomInfo in cachedRoomList)\n{\n// Instantiate a new room button and set its parent.\nRoomButton newButton = Instantiate(theRoomButton, theRoomButton.transform.parent);\n\n// Set the new button's details with the room information.\nnewButton.SetButtonDetails(roomInfo.Value);\n\n// Activate the new button.\nnewButton.gameObject.SetActive(true);\n\n// Add the new button to the list of all room buttons.\nallRoomButtons.Add(newButton);\n}\n}\n</code></pre> <ul> <li>In Unity, assign the <code>theRoomButton</code> and <code>roomBrowserScreen</code> GameObjects to their respective fields in the <code>Launcher</code> script component.</li> <li>Create functions to open and close the room browser in the Launcher script, then wire up the <code>Find Room</code> button to call the <code>OpenRoomBrowser()</code> function and the <code>Leave</code> button to call the <code>CloseRoomBrowser()</code> function.</li> <li>Test the game in Unity to ensure the room buttons are created, updated, and destroyed correctly when browsing available rooms.</li> </ul>"},{"location":"fps-multiplayer/starting-game/#joining-a-room","title":"Joining A Room","text":"<ul> <li>In the <code>Launcher</code> script, create a new function called <code>JoinRoom()</code> that takes in a <code>RoomInfo</code> object as an argument called inputInfo. This function will handle the process of joining a room.   In the <code>RoomButton</code> script, create another function called <code>OpenRoom()</code>. This function will tell the launcher script's instance to run the <code>JoinRoom()</code> function, passing in the stored information about the room that the user wants to join.</li> <li>Back in the <code>Launcher</code> script, within the <code>JoinRoom()</code> function, use the <code>PhotonNetwork.JoinRoom</code> method to join the room by passing in the room name from the <code>inputInfo</code> object: <code>inputInfo.Name</code>.</li> <li>After joining the room, close the open menus, update the loading text to <code>Joining Room</code>, and activate the loading screen.</li> <li>Now, go back to Unity, and on the <code>Room Browser Panel</code>, find the <code>Room Button</code> object under the <code>Content</code> object.</li> <li>Configure the <code>Room Button</code> object to run the <code>RoomButton.OpenRoom</code> function when clicked.</li> <li>Test the implementation by running two instances of the game, one within Unity and another using an older build of the game.</li> <li>Create a room in one instance and use the <code>Room Browser</code> in the other instance to find and join the room.</li> <li>Test the functionality of leaving and rejoining the room.</li> </ul> <p><code>Launcher.cs</code></p> <pre><code>public void JoinRoom(RoomInfo inputInfo)\n{\nPhotonNetwork.JoinRoom(inputInfo.Name);\nCloseMenus();\nloadingText.text = \"Joining Room\";\nloadingScreen.SetActive(true);\n}\n</code></pre> <p><code>RoomButton.cs</code></p> <pre><code> public void OpenRoom()\n{\nLauncher.instance.JoinRoom(info);\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/#quitting-the-game","title":"Quitting The Game","text":"<ul> <li>Open the <code>Launcher</code> script in your code editor.</li> <li>At the bottom of the <code>Launcher</code> script, add the following:</li> </ul> <pre><code>public void QuitGame()\n{\n#if UNITY_EDITOR\nUnityEditor.EditorApplication.isPlaying = false;\n#endif\nApplication.Quit();\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/#listing-players","title":"Listing Players","text":"<ul> <li>In Unity, make necessary changes to the room panel by duplicating the room browser panel and modifying it accordingly.</li> <li>Create a UI TextMeshPro object in the scroll view's content and name it <code>Player Name Label</code>. Make sure it's centered and deactivated by default.</li> <li>In the <code>Launcher</code> script, create references to the <code>playerNameLabel</code> object, a list of <code>TextMeshProUGUI</code> objects called <code>allPlayerNames</code>.</li> <li>Assign a random nickname to each player as they join the lobby by setting <code>PhotonNetwork.NickName</code> to a random number in string format.</li> <li>Create a new private function called <code>ListAllPlayers()</code> in the launcher script.</li> <li>Inside the <code>ListAllPlayers()</code> function, destroy any existing player name labels in the <code>allPlayerNames</code> list, then clear the list.</li> <li>Get the list of players in the room from <code>PhotonNetwork</code> and store it in a <code>Player</code> array called <code>players</code>.</li> <li>Loop through the <code>players</code> array and instantiate a <code>newPlayerLabel</code> for each player. - Set the text of the label to the player's nickname, activate the label, and add it to the <code>allPlayerNames</code> list.</li> <li>Call the <code>ListAllPlayers</code> function when a player joins a room.</li> <li>Assign the <code>playerNameLabel</code> object in Unity to the appropriate field in the <code>Launcher</code> script.</li> <li>Test the implementation by building and running the game. Check if the list of players updates correctly when a new player joins the room.</li> <li>To fix the issue of not seeing all the players when a new player joins, you need to update the list of players whenever a new player joins the room.</li> </ul> <pre><code>public TextMeshProUGUI playerNameLabel;\nprivate List&lt;TextMeshProUGUI&gt; allPlayerNames = new List&lt;TextMeshProUGUI&gt;();\n\npublic override void OnJoinedLobby()\n{\n//..\n\n// Generate a random nickname for a player\nPhotonNetwork.NickName = Random.Range(0, 1000).ToString();\n}\n\npublic override void OnJoinedRoom()\n{\n// ..\nListAllPlayers();\n}\n\nprivate void ListAllPlayers()\n{\n// Clear out existing players\nforeach(TextMeshProUGUI player in allPlayerNames)\n{\nDestroy(player.gameObject);\n}\nallPlayerNames.Clear();\n\n// Retrieve the current list of players and save to the array\nPlayer[] players = PhotonNetwork.PlayerList;\nfor (int i = 0; i &lt; players.Length; i++)\n{\nTextMeshProUGUI newPlayerLabel = Instantiate(playerNameLabel, playerNameLabel.transform.parent);\nnewPlayerLabel.text = players[i].NickName;\nnewPlayerLabel.gameObject.SetActive(true);\nallPlayerNames.Add(newPlayerLabel);\n}\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/#updating-the-player-list","title":"Updating The Player List","text":"<ul> <li>In your <code>Launcher</code> script, add two new override functions:</li> <li><code>public override void OnPlayerEnteredRoom(Player newPlayer)</code>: This function will be executed when a player enters the room.</li> <li><code>public override void OnPlayerLeftRoom(Player otherPlayer)</code>: This function will be executed when a player leaves the room.</li> <li>In the <code>OnPlayerEnteredRoom()</code> and <code>OnPlayerLeftRoom()</code> function, relist all the players in the room by clearing the list and adding the players again.</li> </ul> <p>Note: Make sure to update the <code>Leave Room</code> button in the room panel to actually call the <code>Leave Room</code> function instead of just closing the room browser. This will ensure that the player properly leaves the room and avoids any errors when attempting to create a new room while still being in another room.</p> <pre><code>public override void OnPlayerEnteredRoom(Player newPlayer)\n{\nListAllPlayers();\n}\n\npublic override void OnPlayerLeftRoom(Player otherPlayer)\n{\nListAllPlayers();\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/#players-nickname","title":"Players Nickname","text":"<ul> <li>Duplicate the <code>Create Room</code> panel and rename it as <code>Name Input Panel</code>.</li> <li>Modify the input field placeholder to say <code>Enter Username Here</code>.</li> <li>Update the launcher script with new references:</li> </ul> <pre><code>public GameObject nameInputScreen;\npublic TMP_InputField nameInputField;\nprivate bool hasSetNickname;\n</code></pre> <ul> <li>In the <code>OnJoinLobby()</code> function, add the following code:</li> </ul> <pre><code>if (!hasSetNickname) {\nCloseMenus();\nnameInputScreen.SetActive(true);\n}\n</code></pre> <ul> <li>Update the <code>CloseMenus()</code> function to set <code>nameInputScreen.SetActive(false)</code>:</li> </ul> <pre><code>void CloseMenus()\n{\n//..\nnameInputScreen.SetActive(false);\n}\n</code></pre> <ul> <li>Create a new function <code>SetNickname()</code>:</li> </ul> <pre><code>public void SetNickname()\n{\nif (!string.IsNullOrEmpty(nameInputField.text))\n{\nPhotonNetwork.NickName = nameInputField.text;\nCloseMenus();\nmenuButtons.SetActive(true);\nhasSetNickname = true;\n}\n}\n</code></pre> <ul> <li>In Unity, assign the <code>nameIputField</code> and <code>nameInputSCreen</code> to the appropriate references in the <code>Launcher</code> script.</li> <li>Update the button in <code>Name Input Panel</code> to call <code>SetNickname()</code> function.</li> <li>To store the player name between game sessions, use <code>PlayerPrefs</code>:</li> </ul> <pre><code>public override void OnJoinedLobby()\n{\n//..\nif (!hasSetNickname)\n{\n//..\nif (PlayerPrefs.HasKey(\"playerName\"))\n{\nnameInputField.text = PlayerPrefs.GetString(\"playerName\");\n}\n}\nelse\n{\nPhotonNetwork.NickName = PlayerPrefs.GetString(\"playerName\");\n}\n}\n\npublic void SetNickname()\n{\nif (!string.IsNullOrEmpty(nameInputField.text))\n{\nPhotonNetwork.NickName = nameInputField.text;\nPlayerPrefs.SetString(\"playerName\", nameInputField.text);\n//..\n}\n}\n</code></pre> <ul> <li>Test the game in Unity to see if the player names are being saved and displayed correctly in the game.</li> </ul>"},{"location":"fps-multiplayer/starting-game/#starting-the-game","title":"Starting The Game","text":"<ul> <li>Duplicate the <code>Leave</code> button in the room panel and name it <code>Start Game</code>.</li> <li>Ensure the button has <code>no function</code> assigned to avoid any accidental actions.</li> <li>Go to the <code>Launcher</code> script in the menu canvas.</li> <li>Set <code>PhotonNetwork.AutomaticallySyncScene = true</code> to allow the Photon network to sync the scene information.</li> <li>Create a public string variable called <code>levelToPlay</code> and assign the level name (<code>Scene Name</code>) you want to load.</li> <li>Create a public function named <code>StartGame()</code> and add the following code:</li> </ul> <pre><code>public void StartGame()\n{\nPhotonNetwork.LoadLevel(levelToPlay);\n}\n</code></pre> <ul> <li>Build and test the game to make sure the button works correctly.</li> <li>Create a <code>public GameObject startButton</code> in the launcher script.</li> <li>Check if the player is the master client using <code>PhotonNetwork.IsMasterClient</code>.</li> <li>If the player is the master client, set the start button to active, otherwise set it to inactive.</li> </ul> <pre><code>public override void OnJoinedRoom()\n{\n//..\nCheckTheMaster();\n}\n\nprivate void CheckTheMaster()\n{\n// Check if we are the master\nif (PhotonNetwork.IsMasterClient)\n{\nstartButton.SetActive(true);\n}\nelse\n{\nstartButton.SetActive(false);\n}\n}\n</code></pre> <ul> <li>Assign the start button in the menu canvas to the appropriate button in the room panel.</li> <li>Save and build the game again to test the changes.</li> <li>After completing these steps, the start game button should only be active for the master client, and pressing it should load the specified level for all players in the room.</li> </ul>"},{"location":"fps-multiplayer/starting-game/#switching-masters","title":"Switching Masters","text":"<ul> <li>To ensure the <code>Start Game</code> button is available for a new master if the current master leaves the room, add the following:</li> </ul> <pre><code>public override void OnMasterClientSwitched(Player newMasterClient)\n{\nCheckTheMaster();\n}\n</code></pre>"},{"location":"fps-multiplayer/starting-game/#editor-test-button","title":"Editor Test Button","text":"<ul> <li>In Unity, add a new button called <code>Test Button</code> to your menu buttons with the label <code>Create Test Room</code>. Make sure the button is deactivated by default.</li> <li>In your <code>Launcher</code> script, add a <code>public GameObject roomTestButton</code>.</li> <li>Add a preprocessor directive to check if the game is running in the Unity Editor:</li> </ul> <pre><code>void Start()\n{\n//..\n\n#if UNITY_EDITOR\nroomTestButton.SetActive(true);\n#endif\n}\n</code></pre> <ul> <li>Create a new public method called <code>QuickJoin()</code> in the <code>Launcher</code> script:</li> </ul> <pre><code>public void QuickJoin()\n{\nRoomOptions options = new RoomOptions();\noptions.MaxPlayers = MAX_PLAYERS;\nPhotonNetwork.CreateRoom(\"Test Room\");\nCloseMenus();\nloadingText.text = \"Creating Test Room\";\nloadingScreen.SetActive(true);\n}\n</code></pre> <ul> <li>In Unity, assign the <code>QuickJoin()</code> function to the <code>Test Button's OnClick</code> event.</li> <li>In the <code>Launcher</code> script, assign the <code>Test Button</code> GameObject to the <code>roomTestButton</code> variable.</li> <li>Test the functionality in the Unity Editor by clicking Play. The Test Button should appear, allowing you to create and join a test room quickly.</li> <li>Build the game and verify that the Test Button does not appear in the built version of the game.</li> </ul>"},{"location":"fps-multiplayer/the-player/","title":"The Player","text":""},{"location":"fps-multiplayer/the-player/#setting-up","title":"Setting Up","text":"<ul> <li>Import the assets using <code>The Unarchiver</code> app on the Mac</li> <li>Create a <code>plane</code> with the scale of <code>100, 100, 100</code></li> <li>Create a dark grey material for the <code>ground</code> and add to the <code>plane</code></li> <li>Create a <code>capsule</code> to represent the <code>player</code> with an orange material</li> <li>Create a <code>cube</code> called <code>object</code> with a blue material</li> <li>Duplicate, scale and rotate the <code>cubes</code> in pairs to create buildings</li> <li>Create a <code>cube</code> as VR googles for the <code>player</code> so we know what way they are facing</li> <li>Make the <code>cube</code> a child of the <code>player</code> and set the default of the googles to the z-axis (default)</li> <li>Add both the <code>plane</code> and the <code>cubes</code> as a child of to a <code>environment</code> object</li> <li>Save the <code>scene</code></li> </ul>"},{"location":"fps-multiplayer/the-player/#understanding-looking-around","title":"Understanding Looking Around","text":"<ul> <li>Make the <code>camera</code> a child of the <code>player</code> so it moves with the player</li> <li>Position the <code>camera</code> at eye level with the <code>player</code></li> <li>Create an empty <code>view point</code> object and move the <code>camera</code> as a child. This will allow the player to look up and down without the body also rotating!</li> <li>Rotate the <code>player</code> and observe the <code>game camera</code> rotating as well. The <code>player</code> body will be used to look left to right and the <code>view point</code> will be used to look up and down</li> </ul> <p>When rotating around the <code>view point</code> you may need to adjust the <code>Clipping Planes</code> of the camera if you are seeing the inside of the goggles</p> <ul> <li>Create a <code>PlayerController</code> script and attach to the <code>player</code></li> </ul>"},{"location":"fps-multiplayer/the-player/#making-the-camera-move","title":"Making The Camera Move","text":"<ul> <li>Open the <code>PlayerController</code> script and add the following variables:</li> </ul> <pre><code>public Transform viewPoint;\npublic float mouseSensitivity = 1f;\nprivate float verticalRotStore;\nprivate Vector2 mouseInput;\n</code></pre> <ul> <li>In the <code>Update()</code> method add the following code to allow mouse movement along the x axis to rotate the players view along the y axis:</li> </ul> <pre><code>void Update()\n{\n// Get the mouse input on the x and y axes and multiply it by a sensitivity value\nmouseInput = new Vector2(\nInput.GetAxisRaw(\"Mouse X\"),\nInput.GetAxisRaw(\"Mouse Y\")) * mouseSensitivity;\n\n// Set the rotation of the object to a new quaternion that has the same x and z angles as before,\n// but has the y angle increased by the mouse input on the x axis.\ntransform.rotation = Quaternion.Euler(\ntransform.rotation.eulerAngles.x,\ntransform.rotation.eulerAngles.y + mouseInput.x,\ntransform.rotation.eulerAngles.z);\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#looking-up-down","title":"Looking Up &amp; Down","text":"<ul> <li>Add the following code in <code>Update()</code> to allow the player to look up and down while clamping the viewing angle to 60 degrees:</li> </ul> <pre><code>void Update()\n{\n// ...\n\n// Accumulate the vertical rotation based on the user's mouse input.\nverticalRotStore += mouseInput.y;\n\n// Clamp the vertical rotation between -60 and 60 degrees to prevent the camera from rotating too far up or down.\nverticalRotStore = Mathf.Clamp(verticalRotStore, -60f, 60f);\n\n// Set the rotation of the camera to a new quaternion that has the x angle set to the vertical rotation value, which rotates the camera up and down.\n// The y and z angles are set to the current y and z angles of the camera to preserve the horizontal orientation.\nviewPoint.rotation = Quaternion.Euler(\nverticalRotStore,\nviewPoint.rotation.eulerAngles.y,\nviewPoint.rotation.eulerAngles.z);\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#inverting-hiding-the-mouse","title":"Inverting &amp; Hiding The Mouse","text":"<ul> <li>Add a <code>public bool invertLook</code> variable</li> <li>Change <code>verticalRotStore</code> based on this boolean value</li> </ul> <pre><code>- verticalRotStore += mouseInput.y;\n+ verticalRotStore = invertLook ? verticalRotStore - mouseInput.y : verticalRotStore + mouseInput.y;\n</code></pre> <ul> <li>Hide the mouse by updating the <code>Start()</code> method with the following:</li> </ul> <pre><code>void Start()\n{\n// CursorLockMode.Locked value sets the lock state of the cursor to locked,\n// which hides the cursor and locks it to the center of the game window.\nCursor.lockState = CursorLockMode.Locked;\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#making-the-player-move","title":"Making the Player Move","text":"<ul> <li>Add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>public float moveSpeed = 5f;\nprivate Vector3 moveDir, movement;\n\nvoid Update()\n{\n//..\n\n// Get the horizontal and vertical input axes and create a new direction vector from them.\nmoveDir = new Vector3(Input.GetAxisRaw(\"Horizontal\"), 0f, Input.GetAxisRaw(\"Vertical\"));\n\n// Create a new movement vector from the direction vector and the object's forward and right vectors.\n// Normalize the result to ensure that the movement vector has a magnitude of 1.\nmovement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized;\n\n// Move the object in the direction of the movement vector, scaled by the movement speed and the delta time.\ntransform.position += movement * moveSpeed * Time.deltaTime;\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#interacting-with-the-world","title":"Interacting With The World","text":"<ul> <li>Remove the <code>Capsule Collider</code> component on the <code>player</code> and add a <code>Character Controller</code> instead</li> <li>Create a reference to the <code>CharacterController</code> in the <code>PlayerController</code> script:</li> </ul> <pre><code>public CharacterController characterController;\n</code></pre> <ul> <li>Change the following code in the <code>Update()</code> method:</li> </ul> <pre><code>- transform.position += movement * moveSpeed * Time.deltaTime;\n+ characterController.Move(movement * moveSpeed * Time.deltaTime);\n</code></pre> <ul> <li>Add a <code>cube</code> and rotate it to create a slope. May need to change the <code>slope limit</code> on the <code>CharacterController</code> if you find you can't go up the slope!</li> </ul>"},{"location":"fps-multiplayer/the-player/#moving-at-different-speeds","title":"Moving At Different Speeds","text":"<ul> <li>To allow the player to run when <code>left shift</code> key is being held, we add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>public float runSpeed = 8f;\nprivate float activeMoveSpeed;\n\nvoid Update()\n{\nactiveMoveSpeed = Input.GetKey(KeyCode.LeftShift) ? runSpeed : moveSpeed;\n\n- movement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized;\n+ movement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized * activeMoveSpeed;\n\n- characterController.Move(movement * moveSpeed * Time.deltaTime);\n+ characterController.Move(movement * Time.deltaTime);\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#setting-camera-position","title":"Setting Camera Position","text":"<ul> <li>Remove the <code>camera</code> from the <code>player</code> so that it doesn't disappear if the player dies</li> <li>To achieve this, add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>private Camera playerCamera;\n\nvoid Start() {\n// ..\nplayerCamera = Camera.main;\n}\n\n// Happen after Update()\nvoid LateUpdate() {\nplayerCamera.transform.position = viewPoint.position;\nplayerCamera.transform.rotation = viewPoint.rotation;\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#adding-gravity","title":"Adding Gravity","text":"<ul> <li>Add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>void Update() {\n// ..\n\n// Temporary value for storing the previous movement.y value\nfloat yVelocity = movement.y;\nmovement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized * activeMoveSpeed;\nmovement.y = yVelocity;\n\n// Reset the yVelocity if we are grounded\nif (characterController.isGrounded) movement.y = 0f;\n\n// Take into account gravity\nmovement.y += Physics.gravity.y * Time.deltaTime;\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#jumping","title":"Jumping","text":"<ul> <li>To enable the <code>player</code> to jump, add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>public float jumpForce = 12f;\npublic float gravityModifier = 2.5f;\n\nvoid Update() {\n// ..\n\nif (Input.GetButtonDown(\"Jump\")) {\nmovement.y = jumpForce;\n}\n\n- movement.y += Physics.gravity.y * Time.deltaTime;\n+ movement.y += Physics.gravity.y * Time.deltaTime * gravityModifier;\n}\n</code></pre>"},{"location":"fps-multiplayer/the-player/#staying-grounded","title":"Staying Grounded","text":"<ul> <li>To ensure the <code>player</code> only jumps when they are grounded, add the following to the <code>PlayerController</code> script:</li> </ul> <pre><code>public Transform groundCheckpoint;\nprivate bool isGrounded;\npublic LayerMask groundLayers;\n</code></pre> <ul> <li>Create empty object under <code>player</code> called <code>Ground Check Point</code> and set the <code>y</code> to <code>-0.95</code></li> </ul> <ul> <li>Attach the <code>Ground Check Point</code> to the <code>PlayerController</code> script</li> <li>Add a new layer <code>Ground</code> under <code>Environment</code> object and apply it to all the child objects as well</li> <li>Set <code>groundLayers</code> reference in the <code>PlayerController</code> script to <code>Ground</code> layer</li> </ul> <pre><code>  // Check if the player is grounded by using a Raycast to project a ray against the ground layers\nisGrounded = Physics.Raycast(groundCheckpoint.position, Vector3.down, 0.25f, groundLayers);\n\n// Jumping\n- if (Input.GetButtonDown(\"Jump\")) movement.y = jumpForce;\n+ if (Input.GetButtonDown(\"Jump\") &amp;&amp; isGrounded) movement.y = jumpForce;\n</code></pre>"},{"location":"fps-multiplayer/the-player/#building-the-game-to-test","title":"Building The Game To Test","text":"<ul> <li>Go to <code>File -&gt; Build Settings</code></li> <li>Click <code>Add Open Scenes</code> and select <code>Movement Testing</code></li> <li>To allow it to build quickly set <code>Resolution</code> to <code>Windowed</code> and <code>854 x 480</code></li> <li>Create a <code>Builds</code> folder and build the game</li> <li>When you play the game you will notice we can't free our mouse!</li> </ul>"},{"location":"fps-multiplayer/the-player/#freeing-the-mouse","title":"Freeing The Mouse","text":"<ul> <li>To free the mouse, add the following at the end of the <code>Update()</code> method:</li> </ul> <pre><code>// Handle the mouse in windowed mode\nif (Input.GetKeyDown(KeyCode.Escape)) Cursor.lockState = CursorLockMode.None;\nelse if (Cursor.lockState == CursorLockMode.None\n&amp;&amp; Input.GetMouseButtonDown(0)) Cursor.lockState = CursorLockMode.Locked;\n</code></pre>"},{"location":"fps-multiplayer/the-player/#code-listing","title":"Code Listing","text":""},{"location":"fps-multiplayer/the-player/#playercontrollercs","title":"PlayerController.cs","text":"<pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\npublic Transform viewPoint;\npublic float mouseSensitivity = 1f;\nprivate float verticalRotStore;\nprivate Vector2 mouseInput;\n\npublic bool invertLook;\n\npublic float moveSpeed = 5f;\npublic float runSpeed = 8f;\nprivate float activeMoveSpeed;\nprivate Vector3 moveDir, movement;\n\npublic CharacterController characterController;\nprivate Camera playerCamera;\n\npublic float jumpForce = 12f;\npublic float gravityModifier = 2.5f;\n\npublic Transform groundCheckpoint;\nprivate bool isGrounded;\npublic LayerMask groundLayers;\n\n// Start is called before the first frame update\nvoid Start()\n{\n// CursorLockMode.Locked value sets the lock state of the cursor to locked,\n// which hides the cursor and locks it to the center of the game window.\nCursor.lockState = CursorLockMode.Locked;\nplayerCamera = Camera.main;\n}\n\n// Update is called once per frame\nvoid Update()\n{\n// Get the mouse input on the x and y axes and multiply it by a sensitivity value\nmouseInput = new Vector2(\nInput.GetAxisRaw(\"Mouse X\"),\nInput.GetAxisRaw(\"Mouse Y\")) * mouseSensitivity;\n\n// Set the rotation of the object to a new quaternion that has the same x and z angles as before,\n// but has the y angle increased by the mouse input on the x axis.\ntransform.rotation = Quaternion.Euler(\ntransform.rotation.eulerAngles.x,\ntransform.rotation.eulerAngles.y + mouseInput.x,\ntransform.rotation.eulerAngles.z);\n\nverticalRotStore = invertLook ? verticalRotStore - mouseInput.y : verticalRotStore + mouseInput.y;\nverticalRotStore = Mathf.Clamp(verticalRotStore, -60f, 60f);\n\nviewPoint.rotation = Quaternion.Euler(\nverticalRotStore,\nviewPoint.rotation.eulerAngles.y,\nviewPoint.rotation.eulerAngles.z);\n\nmoveDir = new Vector3(Input.GetAxisRaw(\"Horizontal\"), 0f, Input.GetAxisRaw(\"Vertical\"));\nactiveMoveSpeed = Input.GetKey(KeyCode.LeftShift) ? runSpeed : moveSpeed;\n\nfloat yVelocity = movement.y;\nmovement = ((transform.forward * moveDir.z) + (transform.right * moveDir.x)).normalized * activeMoveSpeed;\nmovement.y = yVelocity;\n\n// Reset the yVelocity if we are grounded\nif (characterController.isGrounded) movement.y = 0f;\n\n// Check if the player is grounded by using a Raycast\nisGrounded = Physics.Raycast(groundCheckpoint.position, Vector3.down, 0.25f, groundLayers);\n\n// Jumping\nif (Input.GetButtonDown(\"Jump\") &amp;&amp; isGrounded) movement.y = jumpForce;\n\n// Take into account gravity\nmovement.y += Physics.gravity.y * Time.deltaTime * gravityModifier;\ncharacterController.Move(movement * Time.deltaTime);\n\n// Handle the mouse in windowed mode\nif (Input.GetKeyDown(KeyCode.Escape)) Cursor.lockState = CursorLockMode.None;\nelse if (Cursor.lockState == CursorLockMode.None\n&amp;&amp; Input.GetMouseButtonDown(0)) Cursor.lockState = CursorLockMode.Locked;\n\n}\n\nvoid LateUpdate()\n{\nplayerCamera.transform.position = viewPoint.position;\nplayerCamera.transform.rotation = viewPoint.rotation;\n}\n}\n</code></pre>"},{"location":"mirror/networked-objects/","title":"Networked Objects","text":""},{"location":"mirror/networked-objects/#networked-objects-in-mirror","title":"Networked Objects in Mirror","text":"<p>Following is an example of how to spawn a network pickup using Mirror</p> <ol> <li> <p>Define all the networked prefabs in the Registered Spawnable Prefabs array in the Network Manager</p> </li> <li> <p>In the Custom Network Manager in OnStartServer() method spawn the first pickup</p> </li> </ol> <pre><code>// Spawn first pickup\nSpawnManager.Instance.SpawnPickups();\n</code></pre> <ol> <li>From the Spawn Manager singleton, call the Command method CmdSpawnPickup() which then creates the prefab and spawns it on the Network Server</li> </ol> <pre><code>[Command(requiresAuthority = false)]\nvoid CmdSpawnPickup(string pickupName, Vector3 spawnPos)\n{\n// Debug.Log($\"Spawning {pickupName}\");\nGameObject pickup = Instantiate(GetSpawnablePrefab(pickupName));\npickup.transform.position = spawnPos;\nNetworkServer.Spawn(pickup);\n}\n</code></pre> <ol> <li>Create a separate script and attach to the networked prefab. Use this script to handle all the desired responses in a networked way.</li> </ol>"},{"location":"mirror/overview/","title":"Mirror","text":""},{"location":"mirror/overview/#project","title":"Project","text":"<p>https://github.com/ton3s/apocalypse</p>"},{"location":"mirror/overview/#tasks","title":"Tasks","text":"<ul> <li> Create a simple scene</li> <li> Setup third person controller with Synty characters</li> <li> Add mirror to allow multiple Synty characters in the scene</li> <li> Add Synty character selection</li> <li> Setup shared status bar</li> <li> Setup solo character animation</li> <li> Refactor to use command pattern for additional animations</li> <li> Number of connected people</li> <li> Add spawned network pickup objects</li> <li> Allow players to pickup objects</li> <li> Track score of people picking up objects</li> <li> Get character to sit in a chair</li> <li> Add smooth camera zoom</li> <li> Add spatial audio when person picks up</li> <li> Travel between scenes</li> <li> Configure state pattern for presents, (Spawning, Idle, Despawning, Collected)</li> </ul>"},{"location":"mirror/overview/#references","title":"References","text":"<p>Networking</p> <ul> <li>Mirror Documentation</li> <li>Network Unity with Third Person Controller</li> </ul> <p>Fonts</p> <ul> <li>Import Custom Fonts</li> <li>Baloo Chetan Font</li> </ul> <p>Testing</p> <ul> <li>ParrelSync</li> </ul> <p>Animations https://www.youtube.com/watch?v=bRIpwQUUN24&amp;t=84s</p>"},{"location":"pun-engine/overview/","title":"Photon PUN v2","text":""},{"location":"pun-engine/overview/#architecture","title":"Architecture","text":"<p>Everyone connects to a \"Name Server\" first. It checks which app (with the AppId) and which region the client wants to use. Then it forwards the client to a Master Server.</p> <p>The Master Server is the hub for a bunch of regional servers. It knows all rooms for this region. Any time a room (match / game) gets created or joined, the client gets forwarded to one of the other machines, called \"Game Server\".</p>"},{"location":"pun-engine/overview/#tips","title":"Tips","text":"<ul> <li>Best way to resuse <code>GameObjects</code> is to turn them into <code>prefabs</code></li> <li><code>Prefabs</code> that should get instaniated over the network </li> </ul>"},{"location":"unity/assets/","title":"Unity Assets","text":""},{"location":"unity/assets/#utilities","title":"Utilities","text":"<ul> <li>DOTween Pro</li> <li>Odin Inspector and Serializer</li> <li>Odin Validator</li> <li>Hot Reload | Edit Code Without Compiling</li> <li>Smooth Sync</li> <li>Dissonance Voice Chat</li> <li>Easy Collider Editor</li> <li>OneJS</li> <li>Text Animator for Unity</li> <li>Quantum Console</li> </ul>"},{"location":"unity/assets/#games","title":"Games","text":"<ul> <li>Feel</li> <li>Dialogue System for Unity</li> <li>Quest Machine</li> <li>Easy Save</li> </ul>"},{"location":"unity/assets/#templates","title":"Templates","text":"<ul> <li>Survival Engine Online</li> <li>Colony Simulator</li> <li>Mini Map</li> </ul>"},{"location":"unity/books/","title":"Unity Books","text":"<p>Following are the various learning tasks in books to work through to build a proficiency in building immersives worlds in Unity</p>"},{"location":"unity/books/#unity-development-cookbook-2nd-edition","title":"Unity Development Cookbook - 2nd Edition","text":"<p>https://github.com/ton3s/unity-development-cookbook</p>"},{"location":"unity/books/#working-in-unity","title":"Working in Unity","text":"<ul> <li> 1.1. Getting Around in Unity</li> <li> 1.2. Working with Game Objects</li> <li> 1.3. Working with Components</li> <li> 1.4. Working with Prefabs</li> <li> 1.5. Working with Scenes</li> <li> 1.6. Managing Assets</li> <li> 1.7. Building Unity Projects</li> <li> 1.8. Accessing Preferences</li> <li> 1.9. Installing Unity Packages</li> </ul>"},{"location":"unity/books/#scripting","title":"Scripting","text":"<ul> <li> 2.1. Adding a Script to an Object in a Unity Scene</li> <li> 2.2. Running Code at Specific Times in a Script\u2019s (or Game Object\u2019s) Life</li> <li> 2.3. Creating Frame Rate\u2013Independent Behavior</li> <li> 2.4. Using the Components of a Game Object</li> <li> 2.5. Finding Objects Attached to a Game Object</li> <li> 2.6. Singletons</li> <li> 2.7. Using Coroutines to Manage When Code Runs</li> <li> 2.8. Managing Objects Using an Object Pool</li> <li> 2.9. Storing Data in Assets Using ScriptableObject</li> </ul>"},{"location":"unity/books/#input","title":"Input","text":"<ul> <li> 3.1. Getting Simple Keyboard Input</li> <li> 3.2. Using the Unity Input System</li> <li> 3.3. Using Input Actions</li> <li> 3.4. Locking and Hiding the Mouse Cursor</li> <li> 3.5. Responding to Mouseover and Click Events</li> </ul>"},{"location":"unity/books/#mathematics","title":"Mathematics","text":"<ul> <li> 4.1. Storing Coordinates of Varying Dimensions Using Vectors</li> <li> 4.2. Rotating in 3D Space</li> <li> 4.3. Performing Transformations in 3D Space with Matrices</li> <li> 4.4. Working with Angles</li> <li> 4.5. Finding the Distance to a Target</li> <li> 4.6. Finding the Angle to a Target</li> </ul>"},{"location":"unity/books/#2d-graphics","title":"2D Graphics","text":"<ul> <li> 5.1. Importing Images as Sprites</li> <li> 5.2. Adding a Sprite to the Scene</li> <li> 5.3. Creating a Sprite Animation</li> <li> 5.4. Creating a Sprite with 2D Physics</li> <li> 5.5. Customizing Sprite Collision Shapes</li> <li> 5.6. Using a Composite Collider</li> <li> 5.7. Using the Sprite Packer</li> <li> 5.8. Applying Forces to 2D Objects</li> <li> 5.9. Creating a Conveyor Belt</li> <li> 5.10. Using a Custom Material for Sprites</li> <li> 5.11. Managing Sprite Sorting</li> <li> 5.12. Using Sorting Groups</li> <li> 5.13. Creating a 2.5D Scene</li> </ul>"},{"location":"unity/books/#3d-graphics","title":"3D Graphics","text":"<ul> <li> 6.1. Creating a Simple Material</li> <li> 6.2. Controlling a Material\u2019s Property Through a Script</li> <li> 6.3. Creating an Unlit Material</li> <li> 6.4. Setting Up a Material Using Textures</li> <li> 6.5. Making a Material Use a Shader</li> <li> 6.6. Setting Up a Bloom Effect Using Post-Processing with the Built-In Render Pipeline</li> <li> 6.7. Setting Up a Bloom Effect Using Post-Processing with the Universal Render Pipeline</li> <li> 6.8. Using High-Dynamic-Range Colors</li> <li> 6.9. Setting Up a Project to Use a Scriptable Render Pipeline</li> <li> 6.10. Creating a Shader Using the Shader Graph</li> <li> 6.11. Creating a Glowing Effect Using the Shader Graph</li> <li> 6.12. Exposing Properties from a Shader Graph</li> <li> 6.13. Animating a Shader over Time</li> <li> 6.14. Controlling the Speed of an Animated Shader</li> <li> 6.15. Using a Subgraph to Reuse Graph Components</li> <li> 6.16. Implementing a Dissolve Effect Using a Shader Graph</li> <li> 6.17. Using Baked Lighting and Real-Time Lighting</li> <li> 6.18. Using Baked Emission Sources</li> <li> 6.19. Making Static Objects Cast Shadows on Dynamic Objects</li> <li> 6.20. Using Light Probes to Influence Lighting</li> <li> 6.21. Using Reflection Probes</li> <li> 6.22. Faking a Dynamic Emissive Object</li> <li> 6.23. Rendering to a Texture</li> </ul>"},{"location":"unity/books/#3d-physics-and-character-control","title":"3D Physics and Character Control","text":"<ul> <li> 7.1. Running Code a Specific Number of Times per Second</li> <li> 7.2. Allowing the Player to Look Around Using the Mouse</li> <li> 7.3. Controlling a 3D Character</li> <li> 7.4. Interacting with Switches and Objects</li> <li> 7.5. Picking Up and Putting Down Objects</li> <li> 7.6. Detecting When an Object Is Touching Another Object</li> <li> 7.7. Detecting When an Object Is in a Trigger Area</li> <li> 7.8. Implementing Moving Platforms</li> <li> 7.9. Implementing Platform Riding</li> <li> 7.10. Responding to Being Pushed by Objects</li> </ul>"},{"location":"unity/books/#animation-and-movement","title":"Animation and Movement","text":"<ul> <li> 8.1. Animating an Object</li> <li> 8.2. Basic Character Movement</li> <li> 8.3. Inverse Kinematics</li> <li> 8.4. Masked Movement</li> <li> 8.5. Blended Movement</li> <li> 8.6. Navigation and Animating in Sync</li> <li> 8.7. Cinematic Camera Tracking</li> <li> 8.8. Automatically Switching Cameras</li> <li> 8.9. Keeping Multiple Objects in View</li> <li> 8.10. Dollying a Camera</li> </ul>"},{"location":"unity/books/#logic-and-gameplay","title":"Logic and Gameplay","text":"<ul> <li> 9.1. Loading a New Scene File</li> <li> 9.2. Managing Hit Points</li> <li> 9.3. Creating a Top-Down Camera</li> <li> 9.4. Managing Quests</li> <li> 9.5. Dragging a Box to Select Objects</li> <li> 9.6. Creating a Menu Structure</li> <li> 9.7. Creating a Wheeled Vehicle</li> <li> 9.8. Keeping a Car from Tipping Over</li> <li> 9.9. Creating Speed Boosts</li> <li> 9.10. Creating a Camera That Orbits Around Its Target</li> <li> 9.11. Creating an Orbiting Camera That Won\u2019t Clip Through Walls</li> <li> 9.12. Detecting When the Player Has Completed a Lap</li> </ul>"},{"location":"unity/books/#behavior-simulation-and-ai","title":"Behavior, Simulation, and AI","text":"<ul> <li> 10.1. Enemies Detecting When They Can See the Player</li> <li> 10.2. Defining a Path That AI Entities and the Player Can Follow</li> <li> 10.3. Letting Entities in Your Game Follow a Path</li> <li> 10.4. Finding a Good Distribution of Random Points (Poisson Disc)</li> <li> 10.5. Enemies Detecting Where They Can Take Cover</li> <li> 10.6. Building and Using a State Machine</li> <li> 10.7. Building a Simulation Environment for Machine Learning</li> </ul>"},{"location":"unity/books/#sound-and-music","title":"Sound and Music","text":"<ul> <li> 11.1. Playing Sounds</li> <li> 11.2. Setting Up a Mixer</li> <li> 11.3. Using Audio Effects</li> <li> 11.4. Using Send and Receive Effects</li> <li> 11.5. Ducking</li> <li> 11.6. Using Multiple Audio Zones</li> <li> 11.7. Playing Audio with Scripts</li> <li> 11.8. Using a Sound Manager</li> </ul>"},{"location":"unity/books/#user-interface","title":"User Interface","text":"<ul> <li> 12.1. Working with UI Controls</li> <li> 12.2. Theming Controls</li> <li> 12.3. Animating the UI</li> <li> 12.4. Creating a List of Items</li> <li> 12.5. Fading Out List Items</li> <li> 12.6. Creating Onscreen Position Indicators</li> <li> 12.7. Custom Editors</li> <li> 12.8. Property Drawers</li> <li> 12.9. Attribute Drawers</li> <li> 12.10. Asset Processing</li> <li> 12.11. Wizards</li> </ul>"},{"location":"unity/books/#files-networking-and-screenshots","title":"Files, Networking, and Screenshots","text":"<ul> <li> 13.1. Saving Files</li> <li> 13.2. Saving an Image File of Your Game to Disk</li> <li> 13.3. Loading Textures from Disk</li> <li> 13.4. Saving and Loading a Game\u2019s State</li> <li> 13.5. Downloading and Parsing JSON from the Web</li> <li> 13.6. Scripted Importers</li> </ul>"},{"location":"unity/dissonance/","title":"Dissonance Voice Chat Integration","text":"<ul> <li>Quick Start Integration with Mirror</li> </ul>"},{"location":"unity/youtube/","title":"Youtube","text":"<p>Following are the various videos and playlists to work through to build a proficiency in building immersives worlds in Unity</p>"},{"location":"unity/youtube/#dark-souls-in-unity","title":"Dark Souls in Unity","text":"<p>https://www.youtube.com/playlist?list=PLD_vBJjpCwJtrHIW1SS5_BNRk6KZJZ7_d</p>"},{"location":"unity/youtube/#playlist","title":"Playlist","text":"<ul> <li> Episode 1 - Movement</li> </ul>"}]}